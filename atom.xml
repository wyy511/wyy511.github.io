<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wiya&#39;s blog</title>
  
  <subtitle>Welcome to Wiya&#39;s blog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wyy511.top/"/>
  <updated>2018-08-29T13:56:10.000Z</updated>
  <id>https://wyy511.top/</id>
  
  <author>
    <name>Wiya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于MVC的JavaScript Web富应用开发(第十篇部署篇)</title>
    <link href="https://wyy511.top/javascript/JSONP%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://wyy511.top/javascript/JSONP学习.html</id>
    <published>2018-08-29T13:50:13.000Z</published>
    <updated>2018-08-29T13:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>参考文档：1.<a href="https://blog.csdn.net/zhoucheng05_13/article/details/78694766" target="_blank" rel="noopener">https://blog.csdn.net/zhoucheng05_13/article/details/78694766</a><br>2.<a href="https://blog.csdn.net/sinat_36422236/article/details/79747419" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36422236/article/details/79747419</a></p></blockquote><h2 id="什么是跨域访问"><a href="#什么是跨域访问" class="headerlink" title="什么是跨域访问"></a>什么是跨域访问</h2><blockquote><p>举个栗子：在A网站中，我们希望使用Ajax来获得B网站中的特定内容。如果A网站与B网站不在同一个域中，那么就出现了跨域访问问题。你可以理解为两个域名之间不能跨过域名来发送请求或者请求数据，否则就是不安全的。跨域访问违反了同源策略，同源策略的详细信息可以点击如下链接：Same-origin_policy；<br>总而言之，同源策略规定，浏览器的ajax只能访问跟它的HTML页面同源（相同域名或IP）的资源。</p></blockquote><p>简单来说就是协议、端口、域名要相同</p><p><img src="https://img-blog.csdn.net/20180329185358157?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="JSONP"></p><h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h2><blockquote><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p></blockquote><pre><code>由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的&lt;script&gt; 元素是一个例外。利用&lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。更具体的原理需要更多篇幅的讲解，小伙伴可以自行去百度。</code></pre><h2 id="JSONP的使用"><a href="#JSONP的使用" class="headerlink" title="JSONP的使用"></a>JSONP的使用</h2><p>前端的使用示例</p><p>JQuery Ajax对JSONP进行了很好的封装，我们使用起来很方便。前端示例：</p><pre><code>$.ajax({    type:&quot;GET&quot;,    url:&quot;http://www.deardull.com:9090/getMySeat&quot;, //访问的链接    dataType:&quot;jsonp&quot;,  //数据格式设置为jsonp    jsonp:&quot;callback&quot;,  //Jquery生成验证参数的名称    success:function(data){  //成功的回调函数        alert(data);    },    error: function (e) {        alert(&quot;error&quot;);    }});</code></pre><p>需要注意的地方是：</p><ul><li>dataType，该参数必须要设置成jsonp</li><li>jsonp，该参数的值需要与服务器端约定，详细情况下面介绍。（约定俗成的默认值为callback） </li></ul><p>jsonp的原理很简单，就是动态的创造script标签，然后利用script的src 不受同源策略约束来跨域获取数据。</p><p>第一步<br>动态创建</p><pre><code>var script = document.createElement(&quot;script&quot;);script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p>我们在这里借助了豆瓣api来实现数据的交互</p><p>第二步<br>在页面中，返回的JSON作为参数传入回调函数中，我们通过回调函数来来操作数据。</p><pre><code>function handleResponse(response){    // 对response数据进行操作代码}&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;JSONP实现跨域2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;mydiv&quot;&gt;        &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function handleResponse(response){            console.log(response);    }&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function() {    var oBtn = document.getElementById(&apos;btn&apos;);    oBtn.onclick = function() {             var script = document.createElement(&quot;script&quot;);        script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;        document.body.insertBefore(script, document.body.firstChild);       };};&lt;/script&gt;&lt;/html&gt;</code></pre><p>jQuery封装JSONP</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;jQuery实现JSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;mydiv&quot;&gt;        &lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-3.1.0.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function(){        $(&quot;#btn&quot;).click(function(){            $.ajax({                async : true,                url : &quot;https://api.douban.com/v2/book/search&quot;,                type : &quot;GET&quot;,                dataType : &quot;jsonp&quot;, // 返回的数据类型，设置为JSONP方式                jsonp : &apos;callback&apos;, //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback                jsonpCallback: &apos;handleResponse&apos;, //设置回调函数名                data : {                    q : &quot;javascript&quot;,                     count : 1                },                 success: function(response, status, xhr){                    console.log(&apos;状态为：&apos; + status + &apos;,状态是：&apos; + xhr.statusText);                    console.log(response);                }            });        });    });&lt;/script&gt;&lt;/html&gt;</code></pre><p>通过$.getJSON()</p><p>利用getJSON来实现，只要在地址中加上callback=?参数即可，参考代码如下：</p><pre><code>$.getJSON(&quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=?&quot;, function(data){    console.log(data);});</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最终，前后端的相应代码应该是这样的：</p><pre><code>$.ajax({    type:&quot;GET&quot;,    url:&quot;http://www.deardull.com:9090/getMySeat&quot;, //访问的链接    dataType:&quot;jsonp&quot;,  //数据格式设置为jsonp    jsonp:&quot;callback&quot;,  //Jquery生成验证参数的名称    success:function(data){  //成功的回调函数        alert(data);    },    error: function (e) {        alert(&quot;error&quot;);    }});</code></pre><p>需要注意的是：</p><ul><li>前端注意与后端沟通约定jsonp的值，通常默认都是用callback。</li><li>后端根据jsonp参数名获取到参数后要与本来要返回的json数据按“callback(json)”的方式构造。</li><li>如果要测试的话记得在跨域环境（两台机器）下进行。</li></ul><h2 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档：1.&lt;a href=&quot;https://blog.csdn.net/zhoucheng05_13/article/details/78694766&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于MVC的JavaScript Web富应用开发(第十篇部署篇)</title>
    <link href="https://wyy511.top/javascript/%E5%9F%BA%E4%BA%8EMVC%E7%9A%84JavaScript%20Web%E5%AF%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91(%E5%8D%81).html"/>
    <id>https://wyy511.top/javascript/基于MVC的JavaScript Web富应用开发(十).html</id>
    <published>2018-08-29T13:48:15.000Z</published>
    <updated>2018-08-29T13:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>阅读《基于MVC的JavaScript Web富应用开发(第十篇部署篇)》</p></blockquote><p>事实上，合理地部署你的web应用程序和开发它一样重要，对于那些使用Facebook的真实用户来说，如果加载速度替身不上去，即使是开发新版的Facebook也无太大意义。用户希望你的站点在提供服务的时候，能尽可能的可靠和快速。部署JavaScript和HTML文件听起来很简单–毕竟他们只是资源文件–但他们的数量相当大，在构建web应用程序中，这一部分数最容易被忽略的。</p><p>幸运的是，已经有一些久经考验的技术，适合所有JavaScript应用程序，事实上他们也适合任何类型的静态文件。如能遵守以下的建议，你将占到自己的方法来加速你的web应用。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li>减少http请求数量</li></ul><blockquote><p>每一个http请求除了有TCP开销外，还包含了大量的头部信息。保持最小的独立链接数可以保证用户的页面加载速度更快，这显然设计到服务器需要传输的数据量的问题。让页面和其资源文件保持较小的体积将减少网络的用时–对任何互联网上的应用而言，这才是真正的瓶颈</p></blockquote><ul><li>将多个脚本合并成一个脚本文件，或将多个css合并成一个样式表</li></ul><blockquote><p>能减少页面渲染所需的http链接的数量。可以在部署或运行时这样做。如果是后者，务必保证生产的文件再生成环境中可以被缓存。</p></blockquote><ul><li><p>使用css sprites技术合并多张小图为一张大图，然后使用css的background-image和background-position属性在页面中显示对应的图片。只需要设定图片要显示的尺寸和背景位置的偏移位置。</p></li><li><p>避免见啥重定向也是减少http请求的数量方法。</p></li></ul><blockquote><p>你也许任务这很少见，其实url结尾缺少斜线（/）是一个最常见的重定向的场景，而这个斜线不应当被丢掉。例如，当前访问<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> 时会被重定向到 <a href="http://baidu.com/。如果使用了Apache，可以使用alias或mod_rewrite来修正这个问题。" target="_blank" rel="noopener">http://baidu.com/。如果使用了Apache，可以使用alias或mod_rewrite来修正这个问题。</a></p></blockquote><ul><li>理解浏览器如何下载资源也很重要。</li></ul><blockquote><p>为了加速页面渲染，现代浏览器并行下载所需要的资源。但是在所有的样式表和脚本下载完成之前，页面时不会开始渲染的。有些浏览器更是变本加厉，在处理忍辱JavaScript文件时，都会阻塞其他资源的下载。</p></blockquote><p>尽管如此，大多数脚本需要访问dom，并且增加一些诸如事件句柄之类的东西，他们会在页面加载完成之后执行。换言之，浏览器没有必要在一些都下载完成之前限制页面的渲染，因为这样做降低了性能，通过设置脚本的defer属性可以解决这个问题–告诉浏览器该脚本不会页面加载完成之前操作dom：</p><pre><code>&lt;script src=&quot;foo.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; defer&gt;&lt;/script&gt;</code></pre><p>defer属性设置为“defer”的脚本将和其他资源一下并行下载，他们不会阻塞页面的渲染。HTML5还引入了一个新的脚本下载和执行的模式。这意味着有可能异步不会按着他们在页面出现的顺序执行代码。这有可能导致脚本执行如有依赖顺序时出错。如果脚本没有依赖关系，async则是很有用的。</p><pre><code>&lt;script src=&quot;http://www.google-analytics.com/ga.js&quot; async&gt;&lt;/script&gt;</code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>如果没有缓存，互联网早就在网络流量拥堵下奔溃了。缓存就是将最近请求的资源存储到本地，以便接下来的请求能从磁盘中使用这些资源，而不再去下载。明确地告诉浏览器什么事可以被缓存的很重要。有些浏览器会使用自己默认的缓存策略，但也不能就此完成依赖他。</p><h2 id="源码压缩"><a href="#源码压缩" class="headerlink" title="源码压缩"></a>源码压缩</h2><p>JavaScript源码压缩是从脚本中文件中删除不必要的字符，它不改变功能。删除的字符包括空白、换行和注释。更好的压缩工具应该能够翻译JavaScript，因此能安全的算变量和函数的名字，这样就进一步减少了字符。文件越小越好，因为在网络上传输的数据越少越好。</p><p>不仅仅可以对JavaScript文件进行压缩，样式表和HTML文件也可以被压缩。特别是样式表，通常包含了大量冗余的空白，压缩最好能在部署时完成，因为开发时你不希望调试任何压缩过的代码。图个在生产环境中有一个错误，首先应该尝试在开发环境中复现–你会发现这样更容易调试代码错误。</p><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>内容分发网络（CDN）为你的站点提供静态资源内容服务，以减少他们的加载时间。用户和web服务器之间的距离对加载时间有直接的影响。CDN将你的内容部署在跨越多个地理位置上的服务器上，故当用户发起一个请求时，可从就近的服务器得到响应资源。</p><h2 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阅读《基于MVC的JavaScript Web富应用开发(第十篇部署篇)》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事实上，合理地部署你的web应用程序和开发它一样重要，对于那些使用Facebook的真实用户来说，如果加载
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>js构造函数</title>
    <link href="https://wyy511.top/javascript/js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html"/>
    <id>https://wyy511.top/javascript/js构造函数.html</id>
    <published>2018-08-24T07:28:13.000Z</published>
    <updated>2018-08-24T13:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p>本文转载：<a href="https://juejin.im/entry/5811b9635bbb50005b868c0e" target="_blank" rel="noopener">https://juejin.im/entry/5811b9635bbb50005b868c0e</a></p><h2 id="js构造函数"><a href="#js构造函数" class="headerlink" title="js构造函数"></a>js构造函数</h2><blockquote><p>类似于java或c#中类的实例化，通过构造函数new出来的对象都是具有相同的特点（属性）和行为（方法），注意，函数构造返回的是一个对象</p></blockquote><h3 id="常规姿态"><a href="#常规姿态" class="headerlink" title="常规姿态"></a>常规姿态</h3><pre><code>// 声明一个“人”的构造函数，目的是通过new出来的对象都是一个个具体的“人”var Person = function () {    // 私有属性，该属性new出来的对象时无法获取到的    var prx = &quot;other&quot;    // 定义了name的属性    // 在这里name是实例属性，也就是说通过new出来的对象都具有name的属性    this.name = &quot;double&quot;    // 我们用var声明了一个私有方法，该方法不能被new Person调用到    // 一般的，我们只需要在内部使用到的方法可最好声明你私有的方法    var prxMethod = function () {      console.log(&apos;in prxMethod&apos;)    }    // 定义了say方法    // 同name，say是一个实例方法，new出来的对象都具有say的方法    this.say = function () {      console.log(&apos;hi, i am &apos; + this.name)    }}// 为Person定义了一个原型方法eat,该方法为公共方法// 每一个通过new Person实例出来的对象都共享同一个eat方法// 当然如果不想共享可在新对象中进行重写覆盖Person.prototype.eat = function () {  console.log(this.name + &apos;eat something&apos;)}// 定义静态方法，该方法目的在于不用new Person就能调用该方法// 我们把不用实例化就能调用的方法叫做静态方法Person.staticMethod = function () {  console.log(&apos;this is a static method)}</code></pre><h3 id="在js中使用new关键字调用一个函数问题"><a href="#在js中使用new关键字调用一个函数问题" class="headerlink" title="在js中使用new关键字调用一个函数问题"></a>在js中使用new关键字调用一个函数问题</h3><pre><code>var zhan = new Person()</code></pre><p>实际上内部是这样的</p><pre><code>var zhan = {}zhan.__proto__ = Person.prototypePerson.call(zhan)</code></pre><p>上面三句话的说明</p><ul><li><p>声明了一个zhan的空对象</p></li><li><p>将Person的prototype赋值给zhan的proto属性</p><p>关于对象的prototype和proto概念如下</p><p>prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。proto是一个对象拥有的内置属性（每个对象都有一个proto属性），是js内部使用寻找原型链的属性</p><p>这就是为什么zhan可以调用到person圆形（Person.prototype）方法的原因</p></li><li><p>调用Person函数，并且把zhan当成是this传入函数中，这就是为什么zhan可以调用Person函数定义的this.属性或this.方法的原因</p></li></ul><h3 id="构造函数返回值的问题"><a href="#构造函数返回值的问题" class="headerlink" title="构造函数返回值的问题"></a>构造函数返回值的问题</h3><blockquote><p>任意一个函数都是有返回值的，如果我们不明确的写出返回值，默认返回的就是undefined，构造函数也是一样</p></blockquote><pre><code>var f = function () {  this.name = &quot;f_name&quot;  this.say = function () {    console.log(&apos;say&apos;)  }  console.log(&apos;in f)}f()// 我们用Chrome执行上面代码获取的结果为：// in f// undefined// 还是上面的f函数，换一个方式调用var fo = new f()fo// 打印结果为// {__proto__:f,name:&quot;f_name&quot;,say:function()arguments: null,caller: null,length: 0,name: &quot;&quot;,prototype....}// 说明该方法返回的是:执行完:fo.__proto__=f.prototype绑定关系和f.call(fo)调用的fo对象.</code></pre><p>如果我们的构造函数有明确的返回值呢</p><pre><code>var f = function () {  this.name = &quot;f_name&quot;  this.say = function () {    console.log(&apos;say&apos;)  }  return &apos;123&apos;}// 非new调用f() // 返回&apos;123&apos;的字符串，这相当于就是调用一个普通的函数// new 调用new f()// 返回值同返回undefined时相同的{__proto__:f,name:&quot;f_name&quot;,say:function()arguments: null,caller: null,length: 0,name: &quot;&quot;,prototype....}</code></pre><p>如果我们返回的值是一个对象呢</p><pre><code>var f=function(){  this.name=&quot;f_name&quot;;  this.say=function(){    console.log(&quot;say&quot;);  }  return {&quot;age&quot;:25}}//非 new调用:f(); //返回{&quot;age&quot;:25}的字符串,这相当于就是调用的一个普通函数//new 调用new f();//返回值是:{age: 25}</code></pre><blockquote><p>也就是说,如果我们的函数明确返回一个对象,则无论是否使用new关键字调用,都获取的是返回的这个对象,这也是很多使用该方法构建模块化的方法和原理</p></blockquote><h3 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h3><blockquote><p>结合上面的例子和原理的理解,下面做一些基本的测试</p></blockquote><pre><code>Person().staticMethod()//报错,因为Person()是一般的函数调用,因为Person没有明确的返回值所以默认返回为undefined,所以 调用代码实际上是undefined.方法,所以error了Person.staticMethod()//打印结果为:this is static method,此次调用的是静态方法,如何定义的就如何调用Person.prototype.eat()//调用原型链中的方法,但eat中的this,指定的是window 所以打印结果为:undefined eat something...var zhangsan=new Person()//先在zhangsan对象中找是否有eat方法发现没有,//则通过__proto__去找,上面我们提到过,//new 关键字调用会将: zhangsan,__proto__=Person.prototype,//所以就会去Person.prototype找eat方法,找到了调用,//而关于this.name获取到值原因同样是因为new 关键字的 Person.call(zhangsan)的执行操作,//将Person中的this相关的内容都进行了&quot;copy&quot;,其实就是this复制到了zhangsan对象中,//关于这点我们前面已验证过了.所以zhangsan.name是能找到值的//输出结果就成了:double eat something...zhangsan.eat()//double eat something...zhangsan.name//同上</code></pre><h3 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;本文转载：&lt;a href=&quot;https://juejin.im/entry/5811b9635bbb50005b868c0e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/entry/5811b9
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="https://wyy511.top/javascript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://wyy511.top/javascript/正则表达式学习.html</id>
    <published>2018-08-23T13:14:13.000Z</published>
    <updated>2018-08-23T13:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p>作者: 一点点征服<br>出处：<a href="http://www.cnblogs.com/ldq2016/" target="_blank" rel="noopener">http://www.cnblogs.com/ldq2016/</a><br>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利</p><h2 id="正则表达式的语法规则"><a href="#正则表达式的语法规则" class="headerlink" title="正则表达式的语法规则"></a>正则表达式的语法规则</h2><p>一、行定位符（^和$）</p><ul><li><p>行定位符就是用来描述字串的边界。“^”表示行的开始；“$”表示行的结尾。如：</p></li><li><p>^tm : 该表达式表示要匹配字串tm的开始位置是行头，如tm equal Tomorrow Moon就可以匹配</p></li><li><p>tm$ : 该表达式表示要匹配字串tm的位置是行尾，Tomorrow Moon equal tm匹配。</p></li><li><p>如果要匹配的字串可以出现在字符串的任意部分，那么可以直接   写成 ：tm</p></li></ul><p>二、单词定界符（\b、\B）</p><ul><li><p>单词分界符\b，表示要查找的字串为一个完整的单词。如：\btm\b</p></li><li><p>还有一个大写的\B，意思和\b相反。它匹配的字串不能是一个完整的单词，而是其他单词或字串的一部分。如：\Btm\B</p></li></ul><p>三、字符类（[ ]）</p><ul><li><p>正则表达式是区分大小写的，如果要忽略大小写可使用方括号表达式“[]”。只要匹配的字符出现在方括号内，即可表示匹配成功。但要注意：一个方括号只能匹配一个字符。例如，要匹配的字串tm不区分大小写，那么该表达式应该写作如下格式：[Tt][Mm]</p></li><li><p>POSIX风格的预定义字符类如表所示：</p></li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115155021197-1614555044.png" alt="POSIX风格的预定义字符类"></p><p>四、选择字符（|）</p><ul><li><p>还有一种方法可以实现上面的匹配模式，就是使用选择字符（|）。该字符可以理解为“或”，如上例也可以写成 (T|t)(M|m)，该表达式的意思是以字母T或t开头，后面接一个字母M或m。</p></li><li><p>使用“[]”和使用“|”的区别在于“[]”只能匹配单个字符，而“|”可以匹配任意长度的字串。如果不怕麻烦，上例还可以写为 ：TM|tm|Tm|tM</p></li></ul><p>五、连字符（-）</p><ul><li><p>变量的命名规则是只能以字母和下划线开头。但这样一来，如果要使用正则表达式来匹配变量名的第一个字母，要写为 ：[a,b,c,d…A,B,C,D…]</p></li><li><p>这无疑是非常麻烦的，正则表达式提供了连字符“-”来解决这个问题。连字符可以表示字符的范围。如上例可以写成 ：[a-zA-Z]</p></li></ul><p>六、排除字符（[^]）</p><ul><li><p>上面的例子是匹配符合命名规则的变量。现在反过来，匹配不符合命名规则的变量，正则表达式提供了“^”字符。这个元字符在前面出现过，表示行的开始。而这里将会放到方括号中，表示排除的意思。</p></li><li><p>例如：[^a-zA-Z]，该表达式匹配的就是不以字母和下划线开头的变量名。</p></li></ul><p>七、限定符（? * + {n,m}）</p><ul><li>对于重复出现字母或字串，可以使用限定符来实现匹配。限定符主要有6种，如表所示：</li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115161554540-1831628852.png" alt="限定符"></p><p>八、点号字符（.）</p><ul><li><p>点字符（.）可以匹配出换行符外的任意一个字符。</p></li><li><p>注意：是除了换行符外的、任意的一个字符。如匹配以s开头、t结尾、中间包含一个字母的单词。</p></li><li><p>格式如下： ^s.t$，匹配的单词包括：sat、set、sit等。</p></li><li><p>再举一个实例，匹配一个单词，它的第一个字母为r，第3个字母为s，最后一个字母为t。能匹配该单词的正则表达式为：^r.s.*t$</p></li></ul><p>九、转义字符（\）</p><ul><li><p>正则表达式中的转移字符（\）和PHP中的大同小异，都是将特殊字符（如“.”、“?”、“\”等）变为普通的字符。举一个IP地址的实例，用正则表达式匹配诸如127.0.0.1这样格式的IP地址。如果直接使用点字符，格式为：[0-9]{1,3}(.[0-9]{1,3}){3}</p></li><li><p>这显然不对，因为“.”可以匹配一个任意字符。这时，不仅是127.0.0.1这样的IP，连127101011这样的字串也会被匹配出来。所以在使用“.”时，需要使用转义字符（\）。修改后上面的正则表达式格式为： [0-9]{1,3}(.[0-9]{1,3}){3}</p></li></ul><p>十、反斜线（\）</p><ul><li>除了可以做转义字符外，反斜线还有其他一些功能。反斜线可以将一些不可打印的字符显示出来，如表所示：</li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115163844290-481664087.png" alt="反斜线"></p><ul><li>还可以指定预定义字符集，如表所示：</li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115164408165-782887623.png" alt="限定符指定预定义字符集"></p><ul><li>反斜线还有一种功能，就是定义断言，其中已经了解过了\b、\B，其他如表所示：</li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115161554540-1831628852.png" alt="限定符定义断言"></p><p>十一、括号字符（()）</p><ul><li><p>小括号字符的第一个作用就是可以改变限定符的作用范围，如“|”、“*”、“^”等。来看下面的一个表达式。</p></li><li><p>(thir|four)th，这个表达式的意思是匹配单词thirth或fourth，如果不使用小括号，那么就变成了匹配单词thir和fourth了。</p></li><li><p>小括号的第二个作用是分组，也就是子表达式。如(.[0-9]{1,3}){3}，就是对分组(.[0-9]{1,3})进行重复操作。后面要学到的反向引用和分组有着直接的关系。</p></li></ul><p>十二、反向引用</p><p>十三、模式修饰符</p><ul><li><p>模式修饰符的作用是设定模式。也就是规定正则表达式应该如何解释和应用。</p></li><li><p>不同的语言都有自己的模式设置，PHP中的主要模式如表所示：</p></li></ul><p><img src="https://images2015.cnblogs.com/blog/831031/201511/831031-20151115165854134-787559901.png" alt="模式修饰符"></p><h5 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;作者: 一点点征服&lt;br&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/ldq2016/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/ldq2016/&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>什么是webpack，为什么要使用它？</title>
    <link href="https://wyy511.top/frame/%E5%85%A5%E9%97%A8webpack.html"/>
    <id>https://wyy511.top/frame/入门webpack.html</id>
    <published>2018-08-22T13:14:13.000Z</published>
    <updated>2018-08-22T13:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>转载文档：<a href="https://www.jianshu.com/p/d745b94ae920" target="_blank" rel="noopener">https://www.jianshu.com/p/d745b94ae920</a></p></blockquote><h5 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h5><blockquote><p>webpack可以看做是模块打包机，它做的事情是分析你的项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（scss，typescript等），并将其打包为合适的格式以供浏览器使用</p></blockquote><h5 id="为什么要使用webpack"><a href="#为什么要使用webpack" class="headerlink" title="为什么要使用webpack"></a>为什么要使用webpack</h5><blockquote><p>今天很多网页可以看做是功能丰富的应用，它们拥有这复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p></blockquote><ul><li><p>a:模块化，让我们可以把复杂的程序细化成小的文件</p></li><li><p>b:类似于typescript这种在JavaScript基础上拓展的开发语言，使我们能够事先目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别</p></li><li><p>c:scss,less等css预处理器</p></li><li><p>……</p></li></ul><blockquote><p>这些改进确实大大的提高了我们的开发效率，但是利用他们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为webpack类的工具出现提供了需求</p></blockquote><h5 id="webpack和grunt以及glup相比有什么特性"><a href="#webpack和grunt以及glup相比有什么特性" class="headerlink" title="webpack和grunt以及glup相比有什么特性"></a>webpack和grunt以及glup相比有什么特性</h5><ul><li><p>其实webpack和另外两个并没有太多的可比性，gulp/grunt是一种能够优化前端的开发流程的工具，而webpack是一种模块化的解决方案，不过webpack的有点使得webpack可以替代glup/grunt类的工具</p></li><li><p>grunt和gulp的工作方式是，在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务</p></li><li><p>webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如index.js），webpack将从这个文件开始找到你的项目所有以来稳健，使用loaders处理他们，最后打包为一个浏览器可识别的javascript文件</p></li></ul><h5 id="优点：模块化"><a href="#优点：模块化" class="headerlink" title="优点：模块化"></a>优点：模块化</h5><blockquote><p>在webpack看来一切都是模块！这就是它不可不说的优点，包括你的JavaScript代码，也包括css和fonts以及图片等待，只有通过合适的loaders，他们都可以被当做模块被处理</p></blockquote><ul><li>1.css</li></ul><blockquote><p>webpack提供两个工具处理样式表，css-loader和style-loader，两者处理的任务不同，css-loader使你能够使用类似@import和url(…)的方法实现require()的功能，style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的js文件中</p></blockquote><p>需要分别安装：npm install  style-loader css-loader –save-dev</p><p><img src="https://upload-images.jianshu.io/upload_images/2367756-cd63ffb26f36ee78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/479" alt="webpack配置"></p><ul><li>2.css modules</li></ul><p>在过去一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展的特别迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，且基于优化工具，依赖管理和加载管理可以自动完成</p><p>不过前端的另外一个部分，css发展就相对慢一些，大多的样式表却依旧是巨大且充满了全局类名，这使得维护和修改都非常困难和复制</p><p>最近一个叫做css modules技术就一在于把js的模块化思想带入css中来，通过css模块，所有的类名，动画名默认都只当作用于当前的模块。webpack从一开始就对css模块化提供了支持，在css loader中进行配置后，你说需要做的一些就是把modules传递到所需要的地方，然后就可以直接把css的类名传递到组件的代码中，且这样做值对当前组件有效，不必担心在不同的模块中具有相同类名可能会造成的问题，具体代码如下</p><p><img src="https://upload-images.jianshu.io/upload_images/2367756-1897b66499fcc8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/618" alt="webpack配置"></p><p>这样相同的类名也不会相互污染</p><ul><li>3.css预编译</li></ul><p>sass和less之类的预处理器是对原生css的拓展，它们允许你使用类似于variables，nesting，mixins，inheritance等不存在与css中的特性来写css，css预处理器可以将这些特殊类型的语句转化为浏览器可识别的css语句</p><p>你现在可能都已经熟悉了，在webpack里使用相关的loader进行配置就可以使用了，一下是常用的css处理loader</p><p>a:less-loader</p><p>b:sass-loader</p><p>c:stylus-loader</p><p>还有一个css处理平台postcss，可以让你用css实现更多功能，比如如何使用postcss，我们使用postcss来为css代码自动添加适应不同浏览器的css前缀</p><p>首先安装postcss-loader和autoprefixer（自动添加前缀的插件）</p><p>npm install postcss-loader autoprefixer –save-dev</p><p>并在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件</p><p><img src="https://upload-images.jianshu.io/upload_images/2367756-4f18f565ae292d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/469" alt="webpack配置"></p><h5 id="webpack-pulgins"><a href="#webpack-pulgins" class="headerlink" title="webpack-pulgins"></a>webpack-pulgins</h5><p>插件（pulgins）是用来拓展webpack功能的，它们会在整个构建过程中生效，执行相关的任务</p><p>loader和pulgins常常被弄混，但是它们其实是完全不同的东西，可以这么说，loader是在打包构建过程中用来处理源文件的（jsx,scss,less），一次处理一个，插件并不是直接操作单个文件，它直接对整个构建过程起作用</p><p>webpack有很多内置的插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能</p><ul><li>如何使用插件</li></ul><p>要使用某个插件，我们需要通过npm安装它，然后要做的是在webpack配置中的pulgins关键字部分添加该插件的一个实例（plugins是一个数组），我们添加了一个实现版权声明的插件，如HtmlWebpackPlugin插件</p><p>该插件的作用是依据一个简单的模板，帮你生成最终的HTML5文件，这个文件中自动引用了你打包后的js文件，每次编译都在文件名中插入一个不同的哈希值</p><p>安装：</p><blockquote><p>npm install html-webpack-plugin –save-dev</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2367756-b8ee65749bcc2a8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/514" alt="webpack配置"></p><h5 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载文档：&lt;a href=&quot;https://www.jianshu.com/p/d745b94ae920&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/d
      
    
    </summary>
    
    
      <category term="前端框架学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>socket.io学习</title>
    <link href="https://wyy511.top/socketio/socket.io%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://wyy511.top/socketio/socket.io学习.html</id>
    <published>2018-08-09T12:15:13.000Z</published>
    <updated>2018-08-09T15:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>转载文档：<a href="https://www.cnblogs.com/xiezhengcai/p/3956401.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiezhengcai/p/3956401.html</a></p></blockquote><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><ul><li>io.on(‘connection’, function(socket)); // 监听客户端返回连接，回调函数会传递本次连接的socket</li><li>io.sockets.emit(‘String’, data); // 给所有客户端广播消息</li><li>io.sockets.socket(socketid).emit(‘String’, data); // 给指定的客户端发送消息</li><li>socket.on(‘String’, function(data)); // 监听客户端发送的消息</li><li>socket.emit(‘String’, data); // 给该socket的客户端发送消息</li></ul><h6 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h6><blockquote><p>给处理自己以为的客户端发送广播消息<br>  socket.broadcast.emit(“msg”, {data: “hello, everyone”});<br>  给所有的客户端广播消息<br>  io.sockets.emit(“msg”, {data: “Hello, all”})</p></blockquote><h6 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h6><blockquote><p>socket.on(‘group1’, (data) =&gt; {<br>    socket.join(‘group1);<br>})<br>socket.on(‘group2’ (data) =&gt; {<br>    socket.join(‘group2);<br>})</p></blockquote><p>客户端发送</p><p>socket.emit(‘group1’) // 就可以加入group1分组<br>socket.emit(‘group2’) // 就可以加入group2分组</p><p>踢出分组</p><p>socket.leave(data.room)</p><p>对分组中的用户发送信息</p><blockquote><p>不包括自己<br>socket.broadcast.to(‘group1’).emit(‘event_name’, data);<br>包括自己<br>io.sockets.in(‘group1’).emit(‘event_name’, data);</p></blockquote><p>broadcast方法允许当前socket client不在该分组内</p><p>获取连接的客户端socket</p><blockquote><p>io.sockets.clients().forEach((socket) =&gt; {<br>    …<br>})</p></blockquote><p>获取分组信息</p><blockquote><p>获取所有房间（分组）信息<br>io.sockets.manager.rooms<br>来获取此socketid进入房间信息<br>io.sockets.manager.roomClients[socket.id]<br>获取particular room中的客户端，返回所有在此房间的socket实例<br>io.sockets.clients(‘particular room’)</p></blockquote><p>另一种分组方式</p><blockquote><p>io.of(‘/some’).on(‘connection’, (socket) =&gt; {<br>    socket.on(‘test’, (data) =&gt; {<br>        socket.broadcast.emit(‘event_name’, {};)<br>    })<br>})</p></blockquote><p>客户端</p><blockquote><p>var socket = io.connect(‘ws://103.31.201.154:5555/some’)</p></blockquote><p>socket.on(‘event_name’, (data) =&gt; {<br>    console.log(data);<br>})</p><p>客户端都连接到ws://103.31.201.154:5555，但是服务器可以通过io.of(‘/some’)将其过滤出来</p><p>另外，socket.io提供了4个配置的API:io.configure, io.set, io.enable, io.disable.其中io.set对单项进行设置，io.enable和io.disable用户单项设置布尔型的配置。io.configure可以让你对不同的生产环境（如development和test等环境）配置不同的参数</p><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>建立一个socket连接</p><p>var socket = io(‘ws://103.31.201.154:5555’);</p><p>监听服务消息</p><blockquote><p>socket.io(‘msg’, (data) =&gt; {<br>    socket.emit(‘msg’, {rp: “fine, thank you”}); // 向服务器发送消息<br>    console.log(data);<br>})</p></blockquote><p>socket.io(‘String’, function(data)) // 监听服务端发送的消息String参数与服务端emit低一个参数相同</p><p>监听socket断开与重连</p><blockquote><p>socket.on(‘disconnect’, () =&gt; {<br>    console.log(‘与服务器断开’);<br>})</p></blockquote><blockquote><p>socket.on(‘reconnect’, () =&gt; {<br>    console.log(‘重连到服务器’);<br>})</p></blockquote><p>客户端socket.on()监听的事件</p><ul><li>connect：连接成功</li><li>connecting：正在连接</li><li>disconnect：断开连接</li><li>connect_failed：连接失败</li><li>error：错误发生，并且无法被其他事件类型所处理</li><li>message：同服务器端message事件</li><li>anything：同服务器端anything事件</li><li>reconnect_failed：重连失败</li><li>reconnect：重连成功</li><li>reconnecting：正在重连</li></ul><blockquote><p>当第一次连接时，事件触发顺序为：connecting =&gt; connect;<br>  当失去连接时，事件触发顺序为：disconnect =&gt; reconnecting（可能进行多次） =&gt; connecting =&gt; reconnect =&gt; connect</p></blockquote><h5 id="本文已完，感谢您的阅读"><a href="#本文已完，感谢您的阅读" class="headerlink" title="本文已完，感谢您的阅读"></a>本文已完，感谢您的阅读</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载文档：&lt;a href=&quot;https://www.cnblogs.com/xiezhengcai/p/3956401.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnb
      
    
    </summary>
    
    
      <category term="前端框架学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js与React.js的全面对比</title>
    <link href="https://wyy511.top/frame/vue-react.html"/>
    <id>https://wyy511.top/frame/vue-react.html</id>
    <published>2018-08-08T03:13:10.000Z</published>
    <updated>2018-08-09T12:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><blockquote><p>转载文档：<a href="https://blog.csdn.net/CystalVon/article/details/78428036" target="_blank" rel="noopener">https://blog.csdn.net/CystalVon/article/details/78428036</a></p></blockquote><h4 id="Vue与React的对比"><a href="#Vue与React的对比" class="headerlink" title="Vue与React的对比"></a>Vue与React的对比</h4><blockquote><p>Vue.js与React.js从默写方面来说很相似，通过两个框架的学习，有时候对一些用法会有点思考，为加深歇息的思索，特从以下各方面进行了对比，加深了对两个框架的认知。</p></blockquote><h5 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h5><h6 id="Vue中有关数据绑定的部分"><a href="#Vue中有关数据绑定的部分" class="headerlink" title="Vue中有关数据绑定的部分"></a>Vue中有关数据绑定的部分</h6><ul><li>vue是双向绑定， Vue.js最核心的功能有两个，一是响应式的数据绑定系统，而是组件系统。所谓双向绑定，是vue实例中的data与其渲染的DOM元素内容一致，无论谁被改变，另一方会相应的更新为相同的数据，这是通过设置属性访问器实现的。</li><li>在vue中，与数据绑定有关的有插值表达式，指令系统，Class和Style，事件处理器和表单控件，ajax请求和计算属性</li></ul><p>1.差值表达式</p><p>插值和指令又称模板语法</p><ul><li>数据绑定最常见的形式就是使用“Mustache”语法（双大括号）的文本插值</li><li>Mustache语法不能作用在HTML特性上，遇到这种情况应该使用v-bind指令</li></ul><p>2.指令</p><ul><li>vue中的指令很方便，指令（Directives）是带有v-前缀的特殊属性。指令属性的值预期是个单个Javascript表达式（v-for是例外情况）指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于dom。</li><li>vue的12个指令：v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock</li></ul><p>3.class与style绑定</p><ul><li>数据绑定的一个常见需求是操作元素的class列表和它的内联样式。因为他们都是属性，我们可以用b-bind来处理他们、只需要计算出表达式最终的字符串，不过，字符串配件麻烦又易错，因此，在v-bind用于class和style时，vue.js专门增强了它，表达式的结果类型除了字符串之外，还可以是对象或数组。</li><li>对象语法<ul><li>我们可以传给v-bind：class一个对象，以动态切换class</li></ul></li><li>数组语法<ul><li>我们可以把一个数组传给v-bind:class，以应用一个class列表<blockquote><p>v-bind:class=”[activeClass, errorClass]”</p></blockquote></li></ul></li></ul><p>4.条件渲染和列表渲染</p><ul><li>v-if条件渲染数组</li><li>我们用v-for指令根据数组的选项列表进行渲染，v-for指令需要使用item in items形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。</li></ul><p>5.事件处理器</p><ul><li>通过v-on给元素注册事件</li><li>使用v-on有几个好处<ul><li>扫一眼HTML模板能轻松定位在JavaScript代码里应对的方法</li><li>因为你无需在JavaScript里手动绑定事件，你的viewmodel代码可以是非常纯粹的逻辑，和dom完全耦合，更易于测试</li><li>当一个viewmodel被销毁时，所有的事件处理器会自动被消除，你无需担心去和自己清理他们</li></ul></li></ul><p>6.表单控件</p><ul><li>v-model在表单控件元素上创建双向数据绑定</li><li>它会根据控件类型自动选取正确的方式来更新元素</li></ul><p>7.计算属性</p><ul><li><p>在vue中引入了计算属性来处理模板中放入太多的逻辑会让模板过重而难以为维护的问题，这样不当解决了上面的问题，而且也同时让模板和业务逻辑更好的分离</p></li><li><p>简单来说，加入data里面有属性a=1，然后你需要一个变量跟着a变化，例如b=a+1,那么就需要用到计算属性，vue实例的computed睡醒中设置b为其属性，其表现为一个函数，返回的是b的值</p></li></ul><p>8.ajax请求</p><ul><li>vue2.0中数据请求推荐使用axios</li></ul><blockquote><p>注：关于vue数据的双向绑定和单向数据流</p></blockquote><ul><li>vue的依赖追踪是【原理上不支持双向绑定，v-model只是通过监听dom时间实现的语法糖】</li><li>vue的依赖追踪是通过Object.defineProperty，把data对象的属性全部转为getter/setter来实现的，当改变数据的某个属性时，会触发set函数，获取该属性值的时候会粗发get函数，通过这个特性来实现改变数据时改变视图，也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过dom时间来改变数据，再由此来改变属兔，以此来双向绑定</li><li>双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联</li><li>组件之间的通信采用单向数据流是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以vue不推荐子组件修改不着急的数据，直接修改props会抛出警告</li></ul><h6 id="react没有数据双向绑定"><a href="#react没有数据双向绑定" class="headerlink" title="react没有数据双向绑定"></a>react没有数据双向绑定</h6><ul><li>react是单向数据流</li><li>react中通过将state（model层）与view层数据进行双向绑定大数据的实时变化更新，具体来说就是在view层直接写js代码，model层中的数据拿过来渲染，一旦像表单操作，触发时间，ajax请求等触发数据变化，则进行双同步</li></ul><p>1.事件处理</p><ul><li>react元素的事件处理和DOM元素很相似，但是有一点点语法上不同<ul><li>react时间绑定属性的命名采用驼峰式写法，而不是小写</li><li>如果采用jsx的语法你需要传入一个函数作为时间处理函数，而不是一个字符串（DOM元素的写法）</li><li>在React中另一个不同时你不能使用返回false的方式阻止默认行为，你必须明确的使用preventDefault</li><li>当你使用ES6 class语法来顶一个组件的时候，事件处理器会成为类的一个方法，一般需要显式的绑定this，例如<blockquote><p>this.handleClick = this.handleClick.bind(this)</p></blockquote></li><li>你必须谨慎对待jsx回调函数中的this，类的方法默认是不会绑定this的，如果你忘记绑定this.handleClick并把它传入onClick，当你调用这个函数的时候this的值会是undefined</li></ul></li></ul><p>2.条件渲染</p><ul><li>react中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或者条件运算来创建标识当前状态的元素，然后让react根据它们来更新UI</li><li>你可以通过使用花括号包裹代码在jsx中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素，之所以能这样做，是因为JavaScript中，true&amp;&amp;expression总是返回expression，而false&amp;&amp;expression总是返回false，因此，如果条件是true，&amp;&amp;右侧的元素就会被渲染，如果是false，react会忽略跳过它</li><li>条件渲染的另一种方式是使用JavaScript的条件运算符condition？true：false</li></ul><p>3.列表渲染</p><ul><li>你可以通过使用{}在jsx内构建一个元素集合，使用JavaScript的map（）方法遍历数组</li><li>keys可以在DOM中的某些元素被增加或删除的时候帮助react识别哪些元素发生了变化，因此你应当给数组中的每个元素赋予一个确定的标识，一个元素的可以最好是这个元素在列表中拥有的一个独一无二的字符串，通常，我们使用来自数据的id作为元素的key</li></ul><p>4.表单操作</p><ul><li>HTML表单元素与react中的其他dom元素有所不同，因为表单元素生来就保留一些内部状态</li><li>当用户提交表单时，HTML的默认行为就会使这个表单跳到一个新页面，在react中也是如此。但大多数情况下，我们会构建一个处理提交表单并可以防卫用户输入表单数据的函数，实现这一点的标准方法是使用一种称为“受控组件”的技术，其值由react控制的输入表单元素称为“受控组件”，this.setState({value: event.target.value})</li><li>当你有处理多个受控的input元素时，你可以通过给每个元素加上name属性，来处理函数event.target.name的值来选择做什么</li></ul><p>5.状态提升</p><ul><li>在react中，状态分享是通过将state数据提升到离这些数据的组件最近的父组件来完成的，这就是所谓的状态提升，this.props.xxx</li><li>在react应哟领中，对用任何可变数据理应只有一个单一的“数据源”，通常，状态都是首先添加在需要渲染的组件中，此时，如果另一个组件也需要这些数据，你可以将数据提升至他们最近的父组件中，你应该在应用中保持自上而下的数据流，而不是尝试在不同组件中同步状态</li></ul><h5 id="组件化以及组件数据流"><a href="#组件化以及组件数据流" class="headerlink" title="组件化以及组件数据流"></a>组件化以及组件数据流</h5><h6 id="react中的组件及数据流"><a href="#react中的组件及数据流" class="headerlink" title="react中的组件及数据流"></a>react中的组件及数据流</h6><ul><li>react是单向数据流，数据主要从父节点传递到子节点（通过props），如果顶层（父级）的某个props改变了，react会重新渲染所有的子节点</li><li>react中实现组件的方式有两种，一种是createClass方法，另一种是通过ES2015的思想类继承React Component来实现</li><li>在react中，按钮，表单，对话框，整个屏幕的内容等，这些通常都被标识为组件</li><li>react推崇的是函数式编程和单向数据流，给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）</li><li>组件可以将UI切成一些独立的，可复用的部件，这样你就只需要专注于构建每个单独的部件，组件从概念上看就像是函数，它可以接受任意的输入值（称为props），并返回一个需要在页面上展示的react元素</li></ul><p>1.props的只读性</p><ul><li>无论是使用函数或是类来声明一个组件，它决不能修改它自己的props</li><li>所有的react组件必须像纯函数那样使用他们的props</li></ul><p>props与state的区别</p><ul><li>props是property的缩写，可以理解为HTML标签的attribute，不可以使用this.props直接修改props，因为props是只读的，props是用于整个组件树中传递数据和配置，在当前组件防卫props，使用this.props</li><li>props是一个组件的设置参数，可以在父组件中选择性设置，父组件对子组件的props进行复制，并且props的值不可以改变，一个子组件自身不能改变自己的props</li><li>state：当一个组件mounts时，state如果设置有默认值的会被使用，并且state可能时刻的被改变，一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子组件的state，所以可以认为，state是子控件自身私有的</li><li>每个组件都有属于自己的state，state和props的区别在于前者（state）值存在于组件内部，只能从当前组件调用this.setState修改state值（不可以直接修改this.state）<br>-props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中，然而state代表的是子组件自身的内部状态。从语义上将，改变组件的状态，可能会导致DOM结构的改变或者重新渲染，而props是父组件传递的参数，所以可以被用于初始化渲染和改变数组自身的状态，虽然大多数时候组件的状态是从外部事件触发改变的，我们需要知道的是，无论是state改版，还是父组件传递的props改变，render方法都可能被执行<br>-一般我们更新子组件都是通过改变state的值，更新子组件的props值从而达到更新</li></ul><p>2.组件之间的通信</p><blockquote><p>父子组件数通信</p></blockquote><pre><code>* 父与子之间痛props属性进行传递* 父与子之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信</code></pre><p>即：</p><ul><li><p>父组件更新组件状态 –props–  子组件更新</p></li><li><p>子组件更新父组件状态 –需要父组件传递回调函数– 子组件调用触发</p></li></ul><blockquote><p>非父组件之间的通信，嵌套不慎的非父子组件可以使用共同父组件，触发时间函数传形参的方式来实现</p></blockquote><ul><li><p>按照react单向数据流方式，我们需要借助父组件来进行传递，通过父组件回调函数改变兄弟组件的props，其实这种实现方式与子组件更新父组件状态的方式是大同小异的</p></li><li><p>当组件层次很深的时候，在这里， react官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层的传递到子组件中</p></li></ul><p>3.组件的生命周期</p><blockquote><p>construtor() //创建组件<br>    componentWillMount() //组件挂载之前<br>    componentDidMount() // 组件挂载之后<br>    componentWillReceiveProps() // 父组件发生render的时候子组件调用该函数<br>    shouldComponentUpdate() // 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回true<br>    componentDidUpdate() // 更新<br>    render() //渲染，react中的核心函数<br>    componentWillUnmount() //组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3333422-04ea055c73c50c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="react生命周期流程"></p><h6 id="vue中的组件及数据流"><a href="#vue中的组件及数据流" class="headerlink" title="vue中的组件及数据流"></a>vue中的组件及数据流</h6><p>1.组件化应用构建</p><ul><li><p>组件系统是vue的另一个重要概念，因为它是一种抽象，允许我们使用小型，独立和通常可复现的组件构建大型应用</p></li><li><p>在vue中，一个组件本质上是一个拥有预定义选项的一个vue实例</p></li><li><p>在一个大型项目中，有必要将整个应用程序划分成组件，以使开发可管理</p></li><li><p>组件是vue最强大的功能之一，组件可以帮助你扩展基本的HTML元素，以封装可重用的代码，在较高层面上，组件是vue编译器附加香味后的自定义元素，在某些情况下，组件也可以是原生HTML元素的形式，以特定的js特性扩展</p></li><li><p>组件中，data必须是一个函数</p></li><li><p>组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义的元素，vue的编译器为它添加特殊功能，在有些情况下，组件也可以是原生HTML元素的形式，以js特性扩展</p></li></ul><p>2.响应式</p><ul><li><p>当一个vue实例被创建时，它向vue的响应式系统中加入了其data对象中能找到的所有属性，当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值</p></li><li><p>当这些数据改变时，视图会重新渲染。值得注意的是只有当实例被创建时，data中存在的属性是响应式的</p></li></ul><p>3.组件的生命周期</p><ul><li><p>每个vue实例在被创建时都要经过一系列的初始化。例如需要设置数据监听，编译模板，挂载实例到DOM，在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码</p></li><li><p>比如created钩子可以用来在一个实例被创建之后执行代码，也有一些其他的钩子，在实例生命周期的不同场景下使用，如mounted,updated,destoryed。钩子的this指向调用它的vue实例</p></li><li><p>生命周期图示</p></li></ul><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期流程"></p><p>4.组件之间的通信</p><ul><li><p>vue默认的是单向数据流，这是vue直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了</p></li><li><p>vue也支持双向绑定，默认为单向绑定，数据从父组件单向传递给子组件。在大型应用中使用单向绑定让数据流更易于理解</p></li><li><p>父子组件的数据通信时通过props和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于angular中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（vuex）</p></li><li><p>在vue中，父子组件之间的关系可以概述为：props向下，events向上。父组件通过props向下传递数据给子组件，子组件通过events发送信息给父组件</p></li></ul><blockquote><p>父向子</p></blockquote><ul><li><p>每个组件实例都有自己的孤立隔离的作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用props将数据向下传递到子组件</p></li><li><p>每个props属性，都可以控制是否从父组件的自定义属性中接受数据，子组件需要使用props选项显示声明props，以便它可以从父组件接收到期望的数据</p></li><li><p>动态props，类似于将一个普通属性绑定到一个表达式，我们还可以使用v-bind将props属性动态的绑定到父组件中的数据。无论父组件何时更新，都可以讲数据向下流入到子组件中</p></li></ul><blockquote><p>子向父</p></blockquote><ul><li><p>使用自定义事件</p></li><li><p>每个vue实例都介入了一个事件接口，也就是说，这些vue实例可以做到</p></li><li><p>使用on监听一个事件，使用emit触发一个事件</p></li></ul><blockquote><p>非父子组件通信</p></blockquote><ul><li>可以使用一个空的vue实例作为一个事件总线中心，用emit触发事件，on监听事件</li></ul><h2 id="后续未完-gt-gt-gt-gt-gt"><a href="#后续未完-gt-gt-gt-gt-gt" class="headerlink" title="后续未完&gt;&gt;&gt;&gt;&gt;"></a>后续未完&gt;&gt;&gt;&gt;&gt;</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转载文档：&lt;a href=&quot;https://blog.csdn.net/CystalVon/article/details/78428036&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://b
      
    
    </summary>
    
    
      <category term="前端框架学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SVG.js学习</title>
    <link href="https://wyy511.top/frame/svg.html"/>
    <id>https://wyy511.top/frame/svg.html</id>
    <published>2018-06-08T03:13:10.000Z</published>
    <updated>2018-06-09T03:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h4 id="SVG-js"><a href="#SVG-js" class="headerlink" title="SVG.js"></a>SVG.js</h4><blockquote><p>SVG 是英文 Scalable Vector Graphics 的缩写，意为可缩放矢量图。<br>  SVG 是用XML格式定义的矢量图。</p></blockquote><ul><li>SVG 1.0 诞生于2001年9月4日</li><li>SVG 表示可缩放矢量图</li><li>SVG 用来定义WEB上使用的矢量图</li><li>SVG 用XML格式定义矢量图</li><li>SVG 在缩放时不会损失任何的图片质量</li><li>SVG 文件里的所有元素和属性都可以运用动画效果</li><li>SVG 是W3C推荐的</li><li>SVG 集成了其它W3C标准，比如 DOM 和 XSL</li></ul><h5 id="SVG-的优势"><a href="#SVG-的优势" class="headerlink" title="SVG 的优势"></a>SVG 的优势</h5><ul><li>SVG 图片可以使用文本编辑器创建和编辑</li><li>SVG 图片能够实现内容搜索，索引，脚本控制和压缩</li><li>SVG 图片是可缩放的</li><li>SVG 图片可以以任意高分辨率打印</li><li>SVG 图片的缩放显示是无损的</li><li>SVG 是开放标准</li><li>SVG 文件是纯XML的</li></ul><blockquote><p>SVG的最大竞争者是Flash。<br>  SVG的优势体现在，它兼容了其它标准(比如，XSL和DOM)。Flash是具有专利的技术，不开源。</p></blockquote><h5 id="创建-SVG-图片"><a href="#创建-SVG-图片" class="headerlink" title="创建 SVG 图片"></a>创建 SVG 图片</h5><blockquote><p>SVG 图片可以使用任何文本编辑器创建，但更高效的还是一些专业绘图软件，比如 Inkscape.</p></blockquote><h5 id="SVG和HTML5"><a href="#SVG和HTML5" class="headerlink" title="SVG和HTML5"></a>SVG和HTML5</h5><blockquote><p>在HTML5里，我们可以直接在html网页里嵌入/使用SVG。</p></blockquote><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;h1&gt;My first SVG&lt;/h1&gt;    &lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;        &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot;        stroke=&quot;green&quot; stroke-width=&quot;4&quot; fill=&quot;yellow&quot;/&gt;    &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>SVG代码说明：</p><pre><code>SVG图片用&lt;svg&gt;标记定义&lt;svg&gt;元素里提供了“width”和“height”两个属性来定义SVG图片的高度和宽度&lt;circle&gt;元素的功能是画出一个圆cx和cy两个属性分别定义了圆心的x坐标和y坐标。如果没有提供cx和cy的值，那么，缺省圆心是(0, 0)r属性定义了圆的半径长度stroke和stroke-width两个属性用来定义图像的边框样子。上面例子中定义圆的边框颜色为green，边框粗细为4pxfill属性定义了圆内部填充的颜色。我们可以看出，例子中填充了黄色。</code></pre><p>注意：因为SVG是XML格式的，所以，所有元素标记必须正确的闭合。</p><h4 id="SVG基础图形"><a href="#SVG基础图形" class="headerlink" title="SVG基础图形"></a>SVG基础图形</h4><blockquote><p>SVG形状<br>  SVG里预定义里一些形状，程序员可以使用这些元素来绘制图形：</p></blockquote><ul><li>矩形 <rect></rect></li><li>圆形 <circle></circle></li><li>椭圆 <ellipse></ellipse></li><li>直线 <line></line></li><li>折线 <polyline></polyline></li><li>多边形 <polygon></polygon></li><li>路径 <path></path></li></ul><h5 id="SVG矩形"><a href="#SVG矩形" class="headerlink" title="SVG矩形"></a>SVG矩形</h5><blockquote><p>rect用来绘制一个矩形，以及类似图形，比如长方形，正方形等。</p></blockquote><p>例 1</p><pre><code>&lt;svg width=&quot;400&quot; height=&quot;110&quot;&gt;    &lt;rect width=&quot;300&quot; height=&quot;100&quot;    style=&quot;fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>&lt;rect&gt;元素里的width和width属性定义了矩形的高度和宽度style属性定义了这个矩形的CSS属性。style属性里的fill属性定义了这个矩形填充的颜色style属性里的stroke-width属性定义了矩形边线的宽度style属性里的stroke属性定义了矩形的边线的颜色</code></pre><p>例 2</p><pre><code>&lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt;    &lt;rect x=&quot;50&quot; y=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot;    style=&quot;fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9&quot;/&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>x属性定义矩形距离左边的距离，比如，x=&quot;50&quot;相对于CSS里的margin-left: 50pxy属性定义了矩形距离上边的距离，比如y=&quot;20&quot;相当于CSS里的margin-top: 20pxCSS fill-opacity属性定义了填充颜色的透明度，值范围为 0 到 1CSS stroke-opacity属性定义了边线颜色的透明度，值范围为 0 到 1</code></pre><p>例 3</p><pre><code>&lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt;    &lt;rect x=&quot;50&quot; y=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot;    style=&quot;fill:blue;stroke:pink;stroke-width:5;opacity:0.5&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>CSS opacity属性定义了整个图形元素的透明度</code></pre><p>例 4</p><pre><code>&lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt;    &lt;rect x=&quot;50&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;150&quot;    height=&quot;150&quot;    style=&quot;fill:red;stroke:black;stroke-width:5;opacity:0.5&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>rx和ry定义了矩形四个角的圆角效果</code></pre><h5 id="SVG圆形"><a href="#SVG圆形" class="headerlink" title="SVG圆形"></a>SVG圆形</h5><blockquote><p>circle元素的作用是绘制圆形：</p></blockquote><pre><code>&lt;svg height=&quot;100&quot; width=&quot;100&quot;&gt;    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot;    stroke-width=&quot;3&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>cx和cy属性是用来定义圆心的坐标。如果没有提供cx和cy的值，则缺省圆心是(0,0)r属性定义了圆的半径长度</code></pre><h5 id="SVG椭圆"><a href="#SVG椭圆" class="headerlink" title="SVG椭圆"></a>SVG椭圆</h5><blockquote><p>ellipse元素的作用是绘制一个椭圆。<br>  椭圆跟圆形很相似。不同之处在于椭圆有两个半径，并且这两个值不同，而圆形也可以说有两个半径，但两个值是相同的：</p></blockquote><p>例 1</p><pre><code>&lt;svg height=&quot;140&quot; width=&quot;500&quot;&gt;    &lt;ellipse cx=&quot;200&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot;    style=&quot;fill:yellow;stroke:purple;stroke-width:2&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>cx属性定义了椭圆的x坐标cy属性定义了椭圆的y坐标rx属性定义了椭圆的横向半径ry属性定义了椭圆的纵向半径</code></pre><p>例 2</p><pre><code>&lt;svg height=&quot;150&quot; width=&quot;500&quot;&gt;    &lt;ellipse cx=&quot;240&quot; cy=&quot;100&quot; rx=&quot;220&quot; ry=&quot;30&quot;    style=&quot;fill:purple&quot; /&gt;    &lt;ellipse cx=&quot;220&quot; cy=&quot;70&quot; rx=&quot;190&quot; ry=&quot;20&quot;    style=&quot;fill:lime&quot; /&gt;    &lt;ellipse cx=&quot;210&quot; cy=&quot;45&quot; rx=&quot;170&quot; ry=&quot;15&quot;    style=&quot;fill:yellow&quot; /&gt;&lt;/svg&gt;</code></pre><p>例 3</p><pre><code>&lt;svg height=&quot;100&quot; width=&quot;500&quot;&gt;    &lt;ellipse cx=&quot;240&quot; cy=&quot;50&quot; rx=&quot;220&quot; ry=&quot;30&quot;    style=&quot;fill:yellow&quot; /&gt;    &lt;ellipse cx=&quot;220&quot; cy=&quot;50&quot; rx=&quot;190&quot; ry=&quot;20&quot;    style=&quot;fill:white&quot; /&gt;&lt;/svg&gt;</code></pre><p>#####</p><blockquote><p>line元素可以用来画出一条直线：</p></blockquote><pre><code>&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt;    &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot;    style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>x1属性定义了直线的x轴起始坐标y1属性定义了直线的y轴起始坐标x2属性定义了直线的x轴终止坐标y2属性定义了直线的y轴终止坐标</code></pre><h5 id="SVG折线"><a href="#SVG折线" class="headerlink" title="SVG折线"></a>SVG折线</h5><blockquote><p><polyline></polyline>元素用来绘制各种各样的折线：</p></blockquote><p>例 1</p><pre><code>&lt;svg height=&quot;200&quot; width=&quot;500&quot;&gt;    &lt;polyline points=&quot;20,20 40,25 60,40 80,120 120,140 200,180&quot;    style=&quot;fill:none;stroke:black;stroke-width:3&quot; /&gt;&lt;/svg&gt;</code></pre><p>例 2</p><pre><code>&lt;svg height=&quot;180&quot; width=&quot;500&quot;&gt;    &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot;    style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>points属性里定义了各个点的坐标，x和y坐标之间用逗号分别，多个坐标之间用空格分割</code></pre><h5 id="SVG多边形"><a href="#SVG多边形" class="headerlink" title="SVG多边形"></a>SVG多边形</h5><blockquote><p>polygon元素用来绘制多边形图形，比如三角形，四边形，五边形等。<br>  多边形是直线围成的图形。<br>  多边形的英文单词是Polygon，来自希腊，”Poly”的意思是”many”，而 “gon” 的意思是 “angle”。</p></blockquote><p>例 1 下面的是用SVG绘制的三角形：</p><pre><code>&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt;    &lt;polygon points=&quot;200,10 250,190 160,210&quot;    style=&quot;fill:lime;stroke:purple;stroke-width:1&quot; /&gt;&lt;/svg&gt;</code></pre><p>代码说明：</p><pre><code>points属性里定义了多边形各个角的x和y坐标，多个坐标间用空格分隔</code></pre><p>例 2 下面是一个四边形：</p><pre><code>&lt;svg height=&quot;250&quot; width=&quot;500&quot;&gt;    &lt;polygon points=&quot;220,10 300,210 170,250 123,234&quot;    style=&quot;fill:lime;stroke:purple;stroke-width:1&quot; /&gt;&lt;/svg&gt;</code></pre><p>例 3 下面我们用 polygon 元素创建一个五角星：</p><pre><code>&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt;    &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot;    style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; /&gt;&lt;/svg&gt;</code></pre><p>例 4 使用fill-rule: evenodd属性：</p><pre><code>&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt;    &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot;    style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt;&lt;/svg&gt;</code></pre><h5 id="SVG路径"><a href="#SVG路径" class="headerlink" title="SVG路径"></a>SVG路径</h5><blockquote><p>path元素可以用来定义一个路径。</p></blockquote><table><thead><tr><th>指令</th><th style="text-align:left">参数</th><th style="text-align:center">名称</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td>M</td><td style="text-align:left">x,y</td><td style="text-align:center">moveto移动到</td><td style="text-align:right">移动虚拟画笔到指定的（x,y）坐标，仅移动不绘制</td></tr><tr><td>m</td><td style="text-align:left">x,y</td><td style="text-align:center">moveto</td><td style="text-align:right">同M，但使用相对坐标</td></tr><tr><td>L</td><td style="text-align:left">x,y</td><td style="text-align:center">lineto连直线到</td><td style="text-align:right">从当前画笔所在位置绘制一条直线到指定的（x,y）坐标</td></tr><tr><td>l</td><td style="text-align:left">x,y</td><td style="text-align:center">lineto</td><td style="text-align:right">同L，但使用相对坐标</td></tr><tr><td>H</td><td style="text-align:left">x</td><td style="text-align:center">horizontal lineto水平连线到</td><td style="text-align:right">绘制一条水平直线到参数指定的x坐标点，y坐标为画笔的y坐标</td></tr><tr><td>h</td><td style="text-align:left">x</td><td style="text-align:center">horizontal lineto</td><td style="text-align:right">同H，但使用相对坐标</td></tr><tr><td>V</td><td style="text-align:left">y</td><td style="text-align:center">vertical lineto垂直连线到</td><td style="text-align:right">从当前位置绘制一条垂直直线到参数指定的y坐标</td></tr><tr><td>v</td><td style="text-align:left">y</td><td style="text-align:center">vertical lineto</td><td style="text-align:right">同V，但使用相对坐标</td></tr><tr><td>C</td><td style="text-align:left">x1,y1 x2,y2 x,y</td><td style="text-align:center">curveto三次方贝塞尔曲线</td><td style="text-align:right">从当前画笔位置绘制一条三次贝兹曲线到参数（x,y）指定的坐标。x1，y1和x2,y2是曲线,开始和结束控制点，用于控制曲线的弧度</td></tr><tr><td>c</td><td style="text-align:left">x1,y1 x2,y2 x,y</td><td style="text-align:center">curveto</td><td style="text-align:right">同C，但使用相对坐标</td></tr><tr><td>S</td><td style="text-align:left">x2,y2 x,y</td><td style="text-align:center">shorthand / 平滑三次方贝塞尔曲线</td><td style="text-align:right">从当前画笔位置绘制一条三次贝塞尔曲线到参数（x,y）指定的坐标。x2,y2是结束控制点.开始控制点和前一条曲线的结束控制点相同</td></tr><tr><td>s</td><td style="text-align:left">x2,y2 x,y</td><td style="text-align:center">shorthand / 平滑三次方贝塞尔曲线</td><td style="text-align:right">同S，但使用相对坐标</td></tr><tr><td>Q</td><td style="text-align:left">x1,y1 x,y</td><td style="text-align:center">二次方贝塞尔曲线</td><td style="text-align:right">从当前画笔位置绘制一条二次方贝塞尔曲线到参数（x,y）指定的坐标。x1,y1是控制点，用于控制曲线的弧度</td></tr><tr><td>q</td><td style="text-align:left">x1,y1 x,y</td><td style="text-align:center">二次方贝塞尔曲线</td><td style="text-align:right">同Q，但使用相对坐标</td></tr><tr><td>T</td><td style="text-align:left">x,y</td><td style="text-align:center">平滑的二次贝塞尔曲线</td><td style="text-align:right">从当前画笔位置绘制一条二次贝塞尔曲线到参数（x,y）指定的坐标。控制点被假定为最后一次使用的控制点</td></tr><tr><td>t</td><td style="text-align:left">x,y</td><td style="text-align:center">平滑的二次贝塞尔曲线</td><td style="text-align:right">同T，但使用相对坐标</td></tr><tr><td>A</td><td style="text-align:left">rx,ry x-axis-rotation large-arc-flag,sweepflag x,y</td><td style="text-align:center">椭圆弧线</td><td style="text-align:right">从当前画笔位置开始绘制一条椭圆弧线到（x,y）指定的坐标。rx和ry分别为椭圆弧线水平和垂直方向上的半径。x-axis-rotation指定弧线绕x轴旋转的度数。它只在rx和ry的值不相同是有效果。large-arc-flag是大弧标志位，取值0或1，用于决定绘制大弧还是小弧。sweep-flag用于决定弧线绘制的方向</td></tr><tr><td>a</td><td style="text-align:left">rx,ry x-axis-rotation large-arc-flag,sweepflag x,y</td><td style="text-align:center">椭圆弧线</td><td style="text-align:right">同A，但使用相对坐标</td></tr><tr><td>Z</td><td style="text-align:left">无</td><td style="text-align:center">闭合路径</td><td style="text-align:right">从结束点绘制一条直线到开始点，闭合路径</td></tr><tr><td>z</td><td style="text-align:left">无</td><td style="text-align:center">闭合路径</td><td style="text-align:right">同Z</td></tr><tr><td></td><td style="text-align:left"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><blockquote><p>注意:所有的这些字符命令都可以用大小写两种形式。大小表示绝对位置，而小写表示相对位置。</p></blockquote><p>例 1</p><pre><code>&lt;svg height=&quot;210&quot; width=&quot;400&quot;&gt;    &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;&lt;/svg&gt;</code></pre><p>例 2 贝塞尔曲线是一种非常顺滑的曲线。通常，用户需要提供两个端点和一个或两个控制点。使用一个控制点的贝塞尔曲线叫做二次方贝塞尔曲线，使用两个控制点的贝塞尔曲线叫做三次方贝塞尔曲线。</p><pre><code>&lt;svg height=&quot;400&quot; width=&quot;450&quot;&gt;    &lt;path id=&quot;lineAB&quot; d=&quot;M 100 350 l 150 -300&quot; stroke=&quot;red&quot;    stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt;    &lt;path id=&quot;lineBC&quot; d=&quot;M 250 50 l 150 300&quot; stroke=&quot;red&quot;    stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt;    &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot;    fill=&quot;none&quot; /&gt;    &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot;    stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt;    &lt;!-- Mark relevant points --&gt;    &lt;g stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;black&quot;&gt;    &lt;circle id=&quot;pointA&quot; cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt;    &lt;circle id=&quot;pointB&quot; cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot; /&gt;    &lt;circle id=&quot;pointC&quot; cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt;    &lt;/g&gt;    &lt;!-- Label the points --&gt;    &lt;g font-size=&quot;30&quot; font-family=&quot;sans-serif&quot; fill=&quot;black&quot; stroke=&quot;none&quot;    text-anchor=&quot;middle&quot;&gt;    &lt;text x=&quot;100&quot; y=&quot;350&quot; dx=&quot;-30&quot;&gt;A&lt;/text&gt;    &lt;text x=&quot;250&quot; y=&quot;50&quot; dy=&quot;-10&quot;&gt;B&lt;/text&gt;    &lt;text x=&quot;400&quot; y=&quot;350&quot; dx=&quot;30&quot;&gt;C&lt;/text&gt;    &lt;/g&gt;&lt;/svg&gt;</code></pre><h5 id="SVG-clipPath"><a href="#SVG-clipPath" class="headerlink" title="SVG clipPath"></a>SVG clipPath</h5><blockquote><p>clipPath标记的作用相当于一个蒙版，它能限制哪些地方可见，哪些地方不可见。<clippath>标记指定的区域之外的所有内     容都不会被显示(图像不会被绘制出来).<br>  clipPath元素需要使用clip-path属性来引用。</clippath></p></blockquote><p>转载svg文档：<a href="http://know.webhek.com/svg/svg-polygon.html" target="_blank" rel="noopener">http://know.webhek.com/svg/svg-polygon.html</a></p><p><a href="https://www.banber.com/banber/5b150dace79d6359cea7a93d.html" target="_blank" rel="noopener">https://www.banber.com/banber/5b150dace79d6359cea7a93d.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;SVG-js&quot;&gt;&lt;a href=&quot;#SVG-js&quot; class=&quot;headerlink&quot; title=&quot;SVG.js&quot;&gt;&lt;/a&gt;SVG.js&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;SVG 是英文 Scalable Vector Graph
      
    
    </summary>
    
    
      <category term="前端框架学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序（applet of WeChat）</title>
    <link href="https://wyy511.top/weixin/wechat-progress.html"/>
    <id>https://wyy511.top/weixin/wechat-progress.html</id>
    <published>2018-06-03T05:21:09.000Z</published>
    <updated>2018-06-03T07:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是微信小程序"><a href="#什么是微信小程序" class="headerlink" title="什么是微信小程序"></a>什么是微信小程序</h4><blockquote><p>微信小程序，简称小程序，是一种不需要下载安装就可以使用的应用程序，它实现了应用“触手可及”的梦想，用户扫一扫或搜索就可以打开应用</p></blockquote><p>特点： 免安装，操作更接近原生APP，必须是在微信中打开</p><h4 id="小程序有哪些宣传方式"><a href="#小程序有哪些宣传方式" class="headerlink" title="小程序有哪些宣传方式"></a>小程序有哪些宣传方式</h4><ul><li><p>小程序搜索入口</p></li><li><p>附近的小程序</p></li><li><p>扫一扫，长按识别小程序码</p></li><li><p>好友分享，群分享</p></li><li><p>关联公众号</p></li><li><p>第三方的小程序应用商店</p></li><li><p>小程序之间可以互相跳转</p></li></ul><h4 id="小程序开发流程"><a href="#小程序开发流程" class="headerlink" title="小程序开发流程"></a>小程序开发流程</h4><p>注册小程序 — 代码开发 — 提审 — 上线</p><h4 id="如何注册小程序"><a href="#如何注册小程序" class="headerlink" title="如何注册小程序"></a>如何注册小程序</h4><ul><li><p>通过公众号注册</p></li><li><p>进入微信小程序官网注册 <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a></p></li></ul><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><blockquote><p>page的生命周期配置：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是微信小程序&quot;&gt;&lt;a href=&quot;#什么是微信小程序&quot; class=&quot;headerlink&quot; title=&quot;什么是微信小程序&quot;&gt;&lt;/a&gt;什么是微信小程序&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;微信小程序，简称小程序，是一种不需要下载安装就可以使用的应用程序，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ajax学习</title>
    <link href="https://wyy511.top/javascript/ajax.html"/>
    <id>https://wyy511.top/javascript/ajax.html</id>
    <published>2018-05-28T10:10:10.000Z</published>
    <updated>2018-08-08T12:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h4 id="AJAX概念"><a href="#AJAX概念" class="headerlink" title="AJAX概念"></a>AJAX概念</h4><blockquote><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。<br>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p></blockquote><blockquote><p>什么是 AJAX ？<br>AJAX = 异步 JavaScript 和 XML。<br>AJAX 是一种用于创建快速动态网页的技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。<br>有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。</p></blockquote><blockquote><p>Google Suggest<br>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。<br>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p></blockquote><h4 id="AJAX-创建-XMLHttpRequest-对象"><a href="#AJAX-创建-XMLHttpRequest-对象" class="headerlink" title="AJAX - 创建 XMLHttpRequest 对象"></a>AJAX - 创建 XMLHttpRequest 对象</h4><blockquote><p>XMLHttpRequest 是 AJAX 的基础。</p></blockquote><p>XMLHttpRequest 对象</p><pre><code>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</code></pre><p>创建 XMLHttpRequest 对象</p><pre><code>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</code></pre><p>创建 XMLHttpRequest 对象的语法：</p><pre><code>variable=new XMLHttpRequest();</code></pre><p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p><pre><code>variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre><p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</p><pre><code>var xmlhttp;if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safarixmlhttp=new XMLHttpRequest();}else{// code for IE6, IE5xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;AJAX概念&quot;&gt;&lt;a href=&quot;#AJAX概念&quot; class=&quot;headerlink&quot; title=&quot;AJAX概念&quot;&gt;&lt;/a&gt;AJAX概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;AJAX = Asynchronous JavaScrip
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>常用工具类的封装（javascript）</title>
    <link href="https://wyy511.top/javascript/js%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85.html"/>
    <id>https://wyy511.top/javascript/js工具类封装.html</id>
    <published>2018-05-23T08:26:10.000Z</published>
    <updated>2018-05-23T09:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><p>本文转载过来<br>作者：cd-dongzi<br>链接：<a href="https://juejin.im/post/5a7523af5188257a7d6e028e" target="_blank" rel="noopener">https://juejin.im/post/5a7523af5188257a7d6e028e</a><br>来源：掘金</p><p>在工作中经常用到这些工具类的封装</p><blockquote><p>Javascript</p></blockquote><h4 id="type-类型判断"><a href="#type-类型判断" class="headerlink" title="type 类型判断"></a>type 类型判断</h4><pre><code>isString (o) { //是否字符串    return Object.prototype.toString.call(o).slice(8, -1) === &apos;String&apos;}isNumber (o) { //是否数字    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Number&apos;}isBoolean (o) { //是否boolean    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Boolean&apos;}isFunction (o) { //是否函数    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Function&apos;}isNull (o) { //是否为null    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Null&apos;}isUndefined (o) { //是否undefined    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Undefined&apos;}isObj (o) { //是否对象    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Object&apos;}isArray (o) { //是否数组    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Array&apos;}isDate (o) { //是否时间    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Date&apos;}isRegExp (o) { //是否正则    return Object.prototype.toString.call(o).slice(8, -1) === &apos;RegExp&apos;}isError (o) { //是否错误对象    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Error&apos;}isSymbol (o) { //是否Symbol函数    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Symbol&apos;}isPromise (o) { //是否Promise对象    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Promise&apos;}isSet (o) { //是否Set对象    return Object.prototype.toString.call(o).slice(8, -1) === &apos;Set&apos;}isFalse (o) {    if (!o || o === &apos;null&apos; || o === &apos;undefined&apos; || o === &apos;false&apos; || o === &apos;NaN&apos;) return true        return false}isTrue (o) {    return !this.isFalse(o)}isIos () {    var u = navigator.userAgent;    if (u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1) {//安卓手机        // return &quot;Android&quot;;        return false    } else if (u.indexOf(&apos;iPhone&apos;) &gt; -1) {//苹果手机        // return &quot;iPhone&quot;;        return true    } else if (u.indexOf(&apos;iPad&apos;) &gt; -1) {//iPad        // return &quot;iPad&quot;;        return false    } else if (u.indexOf(&apos;Windows Phone&apos;) &gt; -1) {//winphone手机        // return &quot;Windows Phone&quot;;        return false    }else{        return false    }}isPC () { //是否为PC端    var userAgentInfo = navigator.userAgent;    var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,                &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,                &quot;iPad&quot;, &quot;iPod&quot;];    var flag = true;    for (var v = 0; v &lt; Agents.length; v++) {        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) {            flag = false;            break;        }    }    return flag;}browserType(){    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器    var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器    var isIE11 = userAgent.indexOf(&apos;Trident&apos;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1;    var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器      var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器    var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器    if (isIE) {        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);        reIE.test(userAgent);        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);        if(fIEVersion == 7) return &quot;IE7&quot;        else if(fIEVersion == 8) return &quot;IE8&quot;;        else if(fIEVersion == 9) return &quot;IE9&quot;;        else if(fIEVersion == 10) return &quot;IE10&quot;;        else return &quot;IE7以下&quot;//IE版本过低    }    if (isIE11) return &apos;IE11&apos;;    if (isEdge) return &quot;Edge&quot;;    if (isFF) return &quot;FF&quot;;    if (isOpera) return &quot;Opera&quot;;    if (isSafari) return &quot;Safari&quot;;    if (isChrome) return &quot;Chrome&quot;;}checkStr (str, type) {    switch (type) {        case &apos;phone&apos;:   //手机号码            return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str);        case &apos;tel&apos;:     //座机            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);        case &apos;card&apos;:    //身份证            return /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test(str);        case &apos;pwd&apos;:     //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线            return /^[a-zA-Z]\w{5,17}$/.test(str)        case &apos;postal&apos;:  //邮政编码            return /[1-9]\d{5}(?!\d)/.test(str);        case &apos;QQ&apos;:      //QQ号            return /^[1-9][0-9]{4,9}$/.test(str);        case &apos;email&apos;:   //邮箱            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);        case &apos;money&apos;:   //金额(小数点2位)            return /^\d*(?:\.\d{0,2})?$/.test(str);        case &apos;URL&apos;:     //网址            return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str)        case &apos;IP&apos;:      //IP            return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str);        case &apos;date&apos;:    //日期时间            return /^(\d{4})\-(\d{2})\-(\d{2}) (\d{2})(?:\:\d{2}|:(\d{2}):(\d{2}))$/.test(str) || /^(\d{4})\-(\d{2})\-(\d{2})$/.test(str)        case &apos;number&apos;:  //数字            return /^[0-9]$/.test(str);        case &apos;english&apos;: //英文            return /^[a-zA-Z]+$/.test(str);        case &apos;chinese&apos;: //中文            return /^[\u4E00-\u9FA5]+$/.test(str);        case &apos;lower&apos;:   //小写            return /^[a-z]+$/.test(str);        case &apos;upper&apos;:   //大写            return /^[A-Z]+$/.test(str);        case &apos;HTML&apos;:    //HTML标记            return /&lt;(&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*&gt;/.test(str);        default:            return true;    }    // 严格的身份证校验    isCardID(sId) {        if (!/(^\d{15}$)|(^\d{17}(\d|X|x)$)/.test(sId)) {            alert(&apos;你输入的身份证长度或格式错误&apos;)            return false        }        //身份证城市        var aCity={11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;};        if(!aCity[parseInt(sId.substr(0,2))]) {             alert(&apos;你的身份证地区非法&apos;)            return false        }        // 出生日期验证        var sBirthday=(sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2))).replace(/-/g,&quot;/&quot;),            d = new Date(sBirthday)        if(sBirthday != (d.getFullYear()+&quot;/&quot;+ (d.getMonth()+1) + &quot;/&quot; + d.getDate())) {            alert(&apos;身份证上的出生日期非法&apos;)            return false        }        // 身份证号码校验        var sum = 0,            weights =  [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],            codes = &quot;10X98765432&quot;        for (var i = 0; i &lt; sId.length - 1; i++) {            sum += sId[i] * weights[i];        }        var last = codes[sum % 11]; //计算出来的最后一位身份证号码        if (sId[sId.length-1] != last) {             alert(&apos;你输入的身份证号非法&apos;)            return false        }        return true    }}</code></pre><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>/**</p><pre><code>* 格式化时间* * @param  {time} 时间* @param  {cFormat} 格式* @return {String} 字符串** @example formatTime(&apos;2018-1-29&apos;, &apos;{y}/{m}/{d} {h}:{i}:{s}&apos;) // -&gt; 2018/01/29 00:00:00</code></pre><p>*/</p><pre><code>formatTime(time, cFormat) {    if (arguments.length === 0) return null    if ((time + &apos;&apos;).length === 10) {        time = +time * 1000    }    var format = cFormat || &apos;{y}-{m}-{d} {h}:{i}:{s}&apos;, date    if (typeof time === &apos;object&apos;) {        date = time    } else {        date = new Date(time)    }    var formatObj = {        y: date.getFullYear(),        m: date.getMonth() + 1,        d: date.getDate(),        h: date.getHours(),        i: date.getMinutes(),        s: date.getSeconds(),        a: date.getDay()    }    var time_str = format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) =&gt; {        var value = formatObj[key]        if (key === &apos;a&apos;) return [&apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;日&apos;][value - 1]        if (result.length &gt; 0 &amp;&amp; value &lt; 10) {            value = &apos;0&apos; + value        }        return value || 0    })    return time_str}</code></pre><p>/**</p><pre><code>* 返回指定长度的月份集合* * @param  {time} 时间* @param  {len} 长度* @param  {direction} 方向：  1: 前几个月;  2: 后几个月;  3:前后几个月  默认 3* @return {Array} 数组* * @example   getMonths(&apos;2018-1-29&apos;, 6, 1)  // -&gt;  [&quot;2018-1&quot;, &quot;2017-12&quot;, &quot;2017-11&quot;, &quot;2017-10&quot;, &quot;2017-9&quot;, &quot;2017-8&quot;, &quot;2017-7&quot;]</code></pre><p>*/</p><pre><code>getMonths(time, len, direction) {    var mm = new Date(time).getMonth(),        yy = new Date(time).getFullYear(),        direction = isNaN(direction) ? 3 : direction,        index = mm;    var cutMonth = function(index) {        if ( index &lt;= len &amp;&amp; index &gt;= -len) {            return direction === 1 ? formatPre(index).concat(cutMonth(++index)):                direction === 2 ? formatNext(index).concat(cutMonth(++index)):formatCurr(index).concat(cutMonth(++index))        }        return []    }    var formatNext = function(i) {        var y = Math.floor(i/12),            m = i%12        return [yy+y + &apos;-&apos; + (m+1)]    }    var formatPre = function(i) {        var y = Math.ceil(i/12),            m = i%12        m = m===0 ? 12 : m        return [yy-y + &apos;-&apos; + (13 - m)]    }    var formatCurr = function(i) {        var y = Math.floor(i/12),            yNext = Math.ceil(i/12),            m = i%12,            mNext = m===0 ? 12 : m        return [yy-yNext + &apos;-&apos; + (13 - mNext),yy+y + &apos;-&apos; + (m+1)]    }    // 数组去重    var unique = function(arr) {        if ( Array.hasOwnProperty(&apos;from&apos;) ) {            return Array.from(new Set(arr));        }else{            var n = {},r=[];             for(var i = 0; i &lt; arr.length; i++){                if (!n[arr[i]]){                    n[arr[i]] = true;                     r.push(arr[i]);                }            }            return r;        }    }    return direction !== 3 ? cutMonth(index) : unique(cutMonth(index).sort(function(t1, t2){        return new Date(t1).getTime() - new Date(t2).getTime()    }))}</code></pre><p>/**</p><pre><code>* 返回指定长度的天数集合* * @param  {time} 时间* @param  {len} 长度* @param  {direction} 方向： 1: 前几天;  2: 后几天;  3:前后几天  默认 3* @return {Array} 数组** @example date.getDays(&apos;2018-1-29&apos;, 6) // -&gt; [&quot;2018-1-26&quot;, &quot;2018-1-27&quot;, &quot;2018-1-28&quot;, &quot;2018-1-29&quot;, &quot;2018-1-30&quot;, &quot;2018-1-31&quot;, &quot;2018-2-1&quot;]</code></pre><p>*/</p><pre><code>getDays(time, len, diretion) {    var tt = new Date(time)    var getDay = function(day) {        var t = new Date(time)        t.setDate(t.getDate() + day)        var m = t.getMonth()+1        return t.getFullYear()+&apos;-&apos;+m+&apos;-&apos;+t.getDate()    }    var arr = []    if (diretion === 1) {        for (var i = 1; i &lt;= len; i++) {            arr.unshift(getDay(-i))        }    }else if(diretion === 2) {        for (var i = 1; i &lt;= len; i++) {            arr.push(getDay(i))        }    }else {        for (var i = 1; i &lt;= len; i++) {            arr.unshift(getDay(-i))        }        arr.push(tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate())        for (var i = 1; i &lt;= len; i++) {            arr.push(getDay(i))        }    }    return diretion === 1 ? arr.concat([tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()]) :         diretion === 2 ? [tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()].concat(arr) : arr}</code></pre><p>/**</p><pre><code>* @param  {s} 秒数* @return {String} 字符串 ** @example formatHMS(3610) // -&gt; 1h0m10s</code></pre><p>*/</p><pre><code>formatHMS (s) {    var str = &apos;&apos;    if (s &gt; 3600) {        str = Math.floor(s/3600)+&apos;h&apos;+Math.floor(s%3600/60)+&apos;m&apos;+s%60+&apos;s&apos;    }else if(s &gt; 60) {        str = Math.floor(s/60)+&apos;m&apos;+s%60+&apos;s&apos;    }else{        str = s%60+&apos;s&apos;    }    return str}/*获取某月有多少天*/getMonthOfDay (time) {    var date = new Date(time)    var year = date.getFullYear()    var mouth = date.getMonth() + 1    var days    //当月份为二月时，根据闰年还是非闰年判断天数    if (mouth == 2) {        days = (year%4==0 &amp;&amp; year%100==0 &amp;&amp; year%400==0) || (year%4==0 &amp;&amp; year%100!=0) ? 28 : 29    } else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) {        //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31；        days = 31    } else {        //其他月份，天数为：30.        days = 30    }    return days}/*获取某年有多少天*/getYearOfDay (time) {    var firstDayYear = this.getFirstDayOfYear(time);    var lastDayYear = this.getLastDayOfYear(time);    var numSecond = (new Date(lastDayYear).getTime() - new Date(firstDayYear).getTime())/1000;    return Math.ceil(numSecond/(24*3600));}/*获取某年的第一天*/getFirstDayOfYear (time) {    var year = new Date(time).getFullYear();    return year + &quot;-01-01 00:00:00&quot;;}/*获取某年最后一天*/getLastDayOfYear (time) {    var year = new Date(time).getFullYear();    var dateString = year + &quot;-12-01 00:00:00&quot;;    var endDay = this.getMonthOfDay(dateString);    return year + &quot;-12-&quot; + endDay + &quot; 23:59:59&quot;;}/*获取某个日期是当年中的第几天*/getDayOfYear (time) {    var firstDayYear = this.getFirstDayOfYear(time);    var numSecond = (new Date(time).getTime() - new Date(firstDayYear).getTime())/1000;    return Math.ceil(numSecond/(24*3600));}/*获取某个日期在这一年的第几周*/getDayOfYearWeek (time) {    var numdays = this.getDayOfYear(time);    return Math.ceil(numdays / 7);}</code></pre><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><pre><code>/*判断一个元素是否在数组中*/contains (arr, val) {    return arr.indexOf(val) != -1 ? true : false;}/*** @param  {arr} 数组* @param  {fn} 回调函数* @return {undefined}*/each (arr, fn) {    fn = fn || Function;    var a = [];    var args = Array.prototype.slice.call(arguments, 1);    for(var i = 0; i &lt; arr.length; i++) {        var res = fn.apply(arr, [arr[i], i].concat(args));        if(res != null) a.push(res);    }}/*** @param  {arr} 数组* @param  {fn} 回调函数* @param  {thisObj} this指向* @return {Array} */map (arr, fn, thisObj) {    var scope = thisObj || window;    var a = [];    for(var i = 0, j = arr.length; i &lt; j; ++i) {        var res = fn.call(scope, arr[i], i, this);        if(res != null) a.push(res);    }    return a;}/*** @param  {arr} 数组* @param  {type} 1：从小到大   2：从大到小   3：随机* @return {Array}*/sort (arr, type = 1) {    return arr.sort( (a, b) =&gt; {        switch(type) {            case 1:                return a - b;            case 2:                return b - a;            case 3:                return Math.random() - 0.5;            default:                return arr;        }    })}/*去重*/unique (arr) {    if ( Array.hasOwnProperty(&apos;from&apos;) ) {        return Array.from(new Set(arr));    }else{        var n = {},r=[];         for(var i = 0; i &lt; arr.length; i++){            if (!n[arr[i]]){                n[arr[i]] = true;                 r.push(arr[i]);            }        }        return r;    }    // 注：上面 else 里面的排重并不能区分 2 和 &apos;2&apos;，但能减少用indexOf带来的性能,暂时没找到替代的方法。。。    /* 正确排重    if ( Array.hasOwnProperty(&apos;from&apos;) ) {        return Array.from(new Set(arr))    }else{        var r = [], NaNBol = true        for(var i=0; i &lt; arr.length; i++) {            if (arr[i] !== arr[i]) {                if (NaNBol &amp;&amp; r.indexOf(arr[i]) === -1) {                    r.push(arr[i])                    NaNBol = false                }            }else{                if(r.indexOf(arr[i]) === -1) r.push(arr[i])            }        }        return r    }    */}/*求两个集合的并集*/union (a, b) {    var newArr = a.concat(b);    return this.unique(newArr);}/*求两个集合的交集*/intersect (a, b) {    var _this = this;    a = this.unique(a);    return this.map(a, function(o) {        return _this.contains(b, o) ? o : null;    });}/*删除其中一个元素*/remove (arr, ele) {    var index = arr.indexOf(ele);    if(index &gt; -1) {        arr.splice(index, 1);    }    return arr;}/*将类数组转换为数组的方法*/formArray (ary) {    var arr = [];    if(Array.isArray(ary)) {        arr = ary;    } else {        arr = Array.prototype.slice.call(ary);    };    return arr;}/*最大值*/max (arr) {    return Math.max.apply(null, arr);}/*最小值*/min (arr) {    return Math.min.apply(null, arr);}/*求和*/sum (arr) {    return arr.reduce( (pre, cur) =&gt; {        return pre + cur    })}/*平均值*/average (arr) {    return this.sum(arr)/arr.length}</code></pre><h4 id="String-字符串操作"><a href="#String-字符串操作" class="headerlink" title="String 字符串操作"></a>String 字符串操作</h4><p>/**</p><pre><code>* 去除空格* @param  {str}* @param  {type} *       type:  1-所有空格  2-前后空格  3-前空格 4-后空格* @return {String}</code></pre><p>*/</p><pre><code>trim (str, type) {    type = type || 1    switch (type) {        case 1:            return str.replace(/\s+/g, &quot;&quot;);        case 2:            return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);        case 3:            return str.replace(/(^\s*)/g, &quot;&quot;);        case 4:            return str.replace(/(\s*$)/g, &quot;&quot;);        default:            return str;    }}</code></pre><p>/**</p><pre><code>* @param  {str} * @param  {type}*       type:  1:首字母大写  2：首页母小写  3：大小写转换  4：全部大写  5：全部小写* @return {String}</code></pre><p>*/</p><pre><code>changeCase (str, type) {    type = type || 4    switch (type) {        case 1:            return str.replace(/\b\w+\b/g, function (word) {                return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();            });        case 2:            return str.replace(/\b\w+\b/g, function (word) {                return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();            });        case 3:            return str.split(&apos;&apos;).map( function(word){                if (/[a-z]/.test(word)) {                    return word.toUpperCase();                }else{                    return word.toLowerCase()                }            }).join(&apos;&apos;)        case 4:            return str.toUpperCase();        case 5:            return str.toLowerCase();        default:            return str;    }}</code></pre><p>/<em><br>    检测密码强度</em>/</p><pre><code>checkPwd (str) {    var Lv = 0;    if (str.length &lt; 6) {        return Lv    }    if (/[0-9]/.test(str)) {        Lv++    }    if (/[a-z]/.test(str)) {        Lv++    }    if (/[A-Z]/.test(str)) {        Lv++    }    if (/[\.|-|_]/.test(str)) {        Lv++    }    return Lv;}/*过滤html代码(把&lt;&gt;转换)*/filterTag (str) {    str = str.replace(/&amp;/ig, &quot;&amp;amp;&quot;);    str = str.replace(/&lt;/ig, &quot;&amp;lt;&quot;);    str = str.replace(/&gt;/ig, &quot;&amp;gt;&quot;);    str = str.replace(&quot; &quot;, &quot;&amp;nbsp;&quot;);    return str;}</code></pre><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>/<em>随机数范围</em>/<br>random (min, max) {<br>    if (arguments.length === 2) {<br>        return Math.floor(min + Math.random() * ( (max+1) - min ))<br>    }else{<br>        return null;<br>    }</p><p>}</p><p>/<em>将阿拉伯数字翻译成中文的大写数字</em>/<br>numberToChinese (num) {<br>    var AA = new Array(“零”, “一”, “二”, “三”, “四”, “五”, “六”, “七”, “八”, “九”, “十”);<br>    var BB = new Array(“”, “十”, “百”, “仟”, “萬”, “億”, “点”, “”);<br>    var a = (“” + num).replace(/(^0*)/g, “”).split(“.”),<br>        k = 0,<br>        re = “”;<br>    for(var i = a[0].length - 1; i &gt;= 0; i–) {<br>        switch(k) {<br>            case 0:<br>                re = BB[7] + re;<br>                break;<br>            case 4:<br>                if(!new RegExp(“0{4}//d{“ + (a[0].length - i - 1) + “}$”)<br>                    .test(a[0]))<br>                    re = BB[4] + re;<br>                break;<br>            case 8:<br>                re = BB[5] + re;<br>                BB[7] = BB[5];<br>                k = 0;<br>                break;<br>        }<br>        if(k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0)<br>            re = AA[0] + re;<br>        if(a[0].charAt(i) != 0)<br>            re = AA[a[0].charAt(i)] + BB[k % 4] + re;<br>        k++;<br>    }</p><pre><code>if(a.length &gt; 1) // 加上小数部分(如果有小数部分){    re += BB[6];    for(var i = 0; i &lt; a[1].length; i++)        re += AA[a[1].charAt(i)];}if(re == &apos;一十&apos;)    re = &quot;十&quot;;if(re.match(/^一/) &amp;&amp; re.length == 3)    re = re.replace(&quot;一&quot;, &quot;&quot;);return re;</code></pre><p>}</p><p>/<em>将数字转换为大写金额</em>/<br>changeToChinese (Num) {<br>        //判断如果传递进来的不是字符的话转换为字符<br>        if(typeof Num == “number”) {<br>            Num = new String(Num);<br>        };<br>        Num = Num.replace(/,/g, “”) //替换tomoney()中的“,”<br>        Num = Num.replace(/ /g, “”) //替换tomoney()中的空格<br>        Num = Num.replace(/￥/g, “”) //替换掉可能出现的￥字符<br>        if(isNaN(Num)) { //验证输入的字符是否为数字<br>            //alert(“请检查小写金额是否正确”);<br>            return “”;<br>        };<br>        //字符处理完毕后开始转换，采用前后两部分分别转换<br>        var part = String(Num).split(“.”);<br>        var newchar = “”;<br>        //小数点前进行转化<br>        for(var i = part[0].length - 1; i &gt;= 0; i–) {<br>            if(part[0].length &gt; 10) {<br>                return “”;<br>                //若数量超过拾亿单位，提示<br>            }<br>            var tmpnewchar = “”<br>            var perchar = part[0].charAt(i);<br>            switch(perchar) {<br>                case “0”:<br>                    tmpnewchar = “零” + tmpnewchar;<br>                    break;<br>                case “1”:<br>                    tmpnewchar = “壹” + tmpnewchar;<br>                    break;<br>                case “2”:<br>                    tmpnewchar = “贰” + tmpnewchar;<br>                    break;<br>                case “3”:<br>                    tmpnewchar = “叁” + tmpnewchar;<br>                    break;<br>                case “4”:<br>                    tmpnewchar = “肆” + tmpnewchar;<br>                    break;<br>                case “5”:<br>                    tmpnewchar = “伍” + tmpnewchar;<br>                    break;<br>                case “6”:<br>                    tmpnewchar = “陆” + tmpnewchar;<br>                    break;<br>                case “7”:<br>                    tmpnewchar = “柒” + tmpnewchar;<br>                    break;<br>                case “8”:<br>                    tmpnewchar = “捌” + tmpnewchar;<br>                    break;<br>                case “9”:<br>                    tmpnewchar = “玖” + tmpnewchar;<br>                    break;<br>            }<br>            switch(part[0].length - i - 1) {<br>                case 0:<br>                    tmpnewchar = tmpnewchar + “元”;<br>                    break;<br>                case 1:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “拾”;<br>                    break;<br>                case 2:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “佰”;<br>                    break;<br>                case 3:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “仟”;<br>                    break;<br>                case 4:<br>                    tmpnewchar = tmpnewchar + “万”;<br>                    break;<br>                case 5:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “拾”;<br>                    break;<br>                case 6:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “佰”;<br>                    break;<br>                case 7:<br>                    if(perchar != 0) tmpnewchar = tmpnewchar + “仟”;<br>                    break;<br>                case 8:<br>                    tmpnewchar = tmpnewchar + “亿”;<br>                    break;<br>                case 9:<br>                    tmpnewchar = tmpnewchar + “拾”;<br>                    break;<br>            }<br>            var newchar = tmpnewchar + newchar;<br>        }<br>        //小数点之后进行转化<br>        if(Num.indexOf(“.”) != -1) {<br>            if(part[1].length &gt; 2) {<br>                // alert(“小数点之后只能保留两位,系统将自动截断”);<br>                part[1] = part[1].substr(0, 2)<br>            }<br>            for(i = 0; i &lt; part[1].length; i++) {<br>                tmpnewchar = “”<br>                perchar = part[1].charAt(i)<br>                switch(perchar) {<br>                    case “0”:<br>                        tmpnewchar = “零” + tmpnewchar;<br>                        break;<br>                    case “1”:<br>                        tmpnewchar = “壹” + tmpnewchar;<br>                        break;<br>                    case “2”:<br>                        tmpnewchar = “贰” + tmpnewchar;<br>                        break;<br>                    case “3”:<br>                        tmpnewchar = “叁” + tmpnewchar;<br>                        break;<br>                    case “4”:<br>                        tmpnewchar = “肆” + tmpnewchar;<br>                        break;<br>                    case “5”:<br>                        tmpnewchar = “伍” + tmpnewchar;<br>                        break;<br>                    case “6”:<br>                        tmpnewchar = “陆” + tmpnewchar;<br>                        break;<br>                    case “7”:<br>                        tmpnewchar = “柒” + tmpnewchar;<br>                        break;<br>                    case “8”:<br>                        tmpnewchar = “捌” + tmpnewchar;<br>                        break;<br>                    case “9”:<br>                        tmpnewchar = “玖” + tmpnewchar;<br>                        break;<br>                }<br>                if(i == 0) tmpnewchar = tmpnewchar + “角”;<br>                if(i == 1) tmpnewchar = tmpnewchar + “分”;<br>                newchar = newchar + tmpnewchar;<br>            }<br>        }<br>        //替换所有无用汉字<br>        while(newchar.search(“零零”) != -1)<br>            newchar = newchar.replace(“零零”, “零”);<br>        newchar = newchar.replace(“零亿”, “亿”);<br>        newchar = newchar.replace(“亿万”, “亿”);<br>        newchar = newchar.replace(“零万”, “万”);<br>        newchar = newchar.replace(“零元”, “元”);<br>        newchar = newchar.replace(“零角”, “”);<br>        newchar = newchar.replace(“零分”, “”);<br>        if(newchar.charAt(newchar.length - 1) == “元”) {<br>            newchar = newchar + “整”<br>        }<br>        return newchar;<br>    }</p><h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><p>/**</p><pre><code>* @param  {setting}</code></pre><p>*/</p><pre><code>ajax(setting){    //设置参数的初始值    var opts={        method: (setting.method || &quot;GET&quot;).toUpperCase(), //请求方式        url: setting.url || &quot;&quot;, // 请求地址        async: setting.async || true, // 是否异步        dataType: setting.dataType || &quot;json&quot;, // 解析方式        data: setting.data || &quot;&quot;, // 参数        success: setting.success || function(){}, // 请求成功回调        error: setting.error || function(){} // 请求失败回调    }    // 参数格式化    function params_format (obj) {        var str = &apos;&apos;        for (var i in obj) {            str += i + &apos;=&apos; + obj[i] + &apos;&amp;&apos;        }        return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;)    }    // 创建ajax对象    var xhr=new XMLHttpRequest();    // 连接服务器open(方法GET/POST，请求地址， 异步传输)    if(opts.method == &apos;GET&apos;){        xhr.open(opts.method, opts.url + &quot;?&quot; + params_format(opts.data), opts.async);        xhr.send();    }else{        xhr.open(opts.method, opts.url, opts.async);        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);        xhr.send(opts.data);    }</code></pre><p>/<em><br>    <strong> 每当readyState改变时，就会触发onreadystatechange事件    </strong> readyState属性存储有XMLHttpRequest的状态信息<br>    <strong> 0 ：请求未初始化    </strong> 1 ：服务器连接已建立<br>    <strong> 2 ：请求已接受    </strong> 3 : 请求处理中<br>    ** 4 ：请求已完成，且相应就绪</em>/</p><pre><code>    xhr.onreadystatechange = function() {        if (xhr.readyState === 4 &amp;&amp; (xhr.status === 200 || xhr.status === 304)) {            switch(opts.dataType){                case &quot;json&quot;:                    var json = JSON.parse(xhr.responseText);                    opts.success(json);                    break;                case &quot;xml&quot;:                    opts.success(xhr.responseXML);                    break;                default:                    opts.success(xhr.responseText);                    break;            }        }    }    xhr.onerror = function(err) {        opts.error(err);    }}</code></pre><p>/**</p><pre><code>* @param  {url}* @param  {setting}* @return {Promise}</code></pre><p>*/</p><pre><code>fetch(url, setting) {    //设置参数的初始值    let opts={        method: (setting.method || &apos;GET&apos;).toUpperCase(), //请求方式        headers : setting.headers  || {}, // 请求头设置        credentials : setting.credentials  || true, // 设置cookie是否一起发送        body: setting.body || {},        mode : setting.mode  || &apos;no-cors&apos;, // 可以设置 cors, no-cors, same-origin        redirect : setting.redirect  || &apos;follow&apos;, // follow, error, manual        cache : setting.cache  || &apos;default&apos; // 设置 cache 模式 (default, reload, no-cache)    }    let dataType = setting.dataType || &quot;json&quot;, // 解析方式          data = setting.data || &quot;&quot; // 参数    // 参数格式化    function params_format (obj) {        var str = &apos;&apos;        for (var i in obj) {            str += `${i}=${obj[i]}&amp;`        }        return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;)    }    if (opts.method === &apos;GET&apos;) {        url = url + (data?`?${params_format(data)}`:&apos;&apos;)    }else{        setting.body = data || {}    }    return new Promise( (resolve, reject) =&gt; {        fetch(url, opts).then( async res =&gt; {            let data = dataType === &apos;text&apos; ? await res.text() :                dataType === &apos;blob&apos; ? await res.blob() : await res.json()             resolve(data)        }).catch( e =&gt; {            reject(e)        })    })}</code></pre><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><pre><code>$ (selector){     var type = selector.substring(0, 1);    if (type === &apos;#&apos;) {        if (document.querySelecotor) return document.querySelector(selector)            return document.getElementById(selector.substring(1))    }else if (type === &apos;.&apos;) {        if (document.querySelecotorAll) return document.querySelectorAll(selector)            return document.getElementsByClassName(selector.substring(1))    }else{        return document[&apos;querySelectorAll&apos; ? &apos;querySelectorAll&apos;:&apos;getElementsByTagName&apos;](selector)    }} /*检测类名*/hasClass (ele, name) {    return ele.className.match(new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;));}/*添加类名*/addClass (ele, name) {    if (!this.hasClass(ele, name)) ele.className += &quot; &quot; + name;}/*删除类名*/removeClass (ele, name) {    if (this.hasClass(ele, name)) {        var reg = new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;);        ele.className = ele.className.replace(reg, &apos;&apos;);    }}/*替换类名*/replaceClass (ele, newName, oldName) {    this.removeClass(ele, oldName);    this.addClass(ele, newName);}/*获取兄弟节点*/siblings (ele) {    console.log(ele.parentNode)    var chid = ele.parentNode.children,eleMatch = [];     for(var i = 0, len = chid.length; i &lt; len; i ++){         if(chid[i] != ele){             eleMatch.push(chid[i]);         }     }     return eleMatch;}/*获取行间样式属性*/getByStyle (obj,name){    if(obj.currentStyle){        return  obj.currentStyle[name];    }else{        return  getComputedStyle(obj,false)[name];    }}</code></pre><h4 id="Storage-储存操作"><a href="#Storage-储存操作" class="headerlink" title="Storage 储存操作"></a>Storage 储存操作</h4><pre><code>class StorageFn {    constructor () {        this.ls = window.localStorage;        this.ss = window.sessionStorage;    }    /*-----------------cookie---------------------*/    /*设置cookie*/    setCookie (name, value, day) {        var setting = arguments[0];        if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){            for (var i in setting) {                var oDate = new Date();                oDate.setDate(oDate.getDate() + day);                document.cookie = i + &apos;=&apos; + setting[i] + &apos;;expires=&apos; + oDate;            }        }else{            var oDate = new Date();            oDate.setDate(oDate.getDate() + day);            document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + oDate;        }    }    /*获取cookie*/    getCookie (name) {        var arr = document.cookie.split(&apos;; &apos;);        for (var i = 0; i &lt; arr.length; i++) {            var arr2 = arr[i].split(&apos;=&apos;);            if (arr2[0] == name) {                return arr2[1];            }        }        return &apos;&apos;;    }    /*删除cookie*/    removeCookie (name) {        this.setCookie(name, 1, -1);    }    /*-----------------localStorage---------------------*/    /*设置localStorage*/    setLocal(key, val) {        var setting = arguments[0];        if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){            for(var i in setting){                this.ls.setItem(i, JSON.stringify(setting[i]))            }        }else{            this.ls.setItem(key, JSON.stringify(val))        }    }    /*获取localStorage*/    getLocal(key) {        if (key) return JSON.parse(this.ls.getItem(key))        return null;    }    /*移除localStorage*/    removeLocal(key) {        this.ls.removeItem(key)    }    /*移除所有localStorage*/    clearLocal() {        this.ls.clear()    }    /*-----------------sessionStorage---------------------*/    /*设置sessionStorage*/    setSession(key, val) {        var setting = arguments[0];        if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){            for(var i in setting){                this.ss.setItem(i, JSON.stringify(setting[i]))            }        }else{            this.ss.setItem(key, JSON.stringify(val))        }    }    /*获取sessionStorage*/    getSession(key) {        if (key) return JSON.parse(this.ss.getItem(key))        return null;    }    /*移除sessionStorage*/    removeSession(key) {        this.ss.removeItem(key)    }    /*移除所有sessionStorage*/    clearSession() {        this.ss.clear()    }}</code></pre><h4 id="Other-其它操作"><a href="#Other-其它操作" class="headerlink" title="Other 其它操作"></a>Other 其它操作</h4><pre><code>/*获取网址参数*/getURL(name){    var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    var r = decodeURI(window.location.search).substr(1).match(reg);    if(r!=null) return  r[2]; return null;}/*获取全部url参数,并转换成json对象*/getUrlAllParams (url) {    var url = url ? url : window.location.href;    var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1),        _arrS = _pa.split(&apos;&amp;&apos;),        _rs = {};    for (var i = 0, _len = _arrS.length; i &lt; _len; i++) {        var pos = _arrS[i].indexOf(&apos;=&apos;);        if (pos == -1) {            continue;        }        var name = _arrS[i].substring(0, pos),            value = window.decodeURIComponent(_arrS[i].substring(pos + 1));        _rs[name] = value;    }    return _rs;}/*删除url指定参数，返回url*/delParamsUrl(url, name){    var baseUrl = url.split(&apos;?&apos;)[0] + &apos;?&apos;;    var query = url.split(&apos;?&apos;)[1];    if (query.indexOf(name)&gt;-1) {        var obj = {}        var arr = query.split(&quot;&amp;&quot;);        for (var i = 0; i &lt; arr.length; i++) {            arr[i] = arr[i].split(&quot;=&quot;);            obj[arr[i][0]] = arr[i][1];        };        delete obj[name];        var url = baseUrl + JSON.stringify(obj).replace(/[\&quot;\{\}]/g,&quot;&quot;).replace(/\:/g,&quot;=&quot;).replace(/\,/g,&quot;&amp;&quot;);        return url    }else{        return url;    }}/*获取十六进制随机颜色*/getRandomColor () {    return &apos;#&apos; + (function(h) {        return new Array(7 - h.length).join(&quot;0&quot;) + h;    })((Math.random() * 0x1000000 &lt;&lt; 0).toString(16));}/*图片加载*/imgLoadAll(arr,callback){    var arrImg = [];     for (var i = 0; i &lt; arr.length; i++) {        var img = new Image();        img.src = arr[i];        img.onload = function(){            arrImg.push(this);            if (arrImg.length == arr.length) {                callback &amp;&amp; callback();            }        }    }}/*音频加载*/loadAudio(src, callback) {    var audio = new Audio(src);    audio.onloadedmetadata = callback;    audio.src = src;}/*DOM转字符串*/domToStirng(htmlDOM){    var div= document.createElement(&quot;div&quot;);    div.appendChild(htmlDOM);    return div.innerHTML}/*字符串转DOM*/stringToDom(htmlString){    var div= document.createElement(&quot;div&quot;);    div.innerHTML=htmlString;    return div.children[0];}</code></pre><p>/**</p><pre><code>* 光标所在位置插入字符，并设置光标位置* * @param {dom} 输入框* @param {val} 插入的值* @param {posLen} 光标位置处在 插入的值的哪个位置</code></pre><p>*/</p><pre><code>setCursorPosition (dom,val,posLen) {    var cursorPosition = 0;    if(dom.selectionStart){        cursorPosition = dom.selectionStart;    }    this.insertAtCursor(dom,val);    dom.focus();    console.log(posLen)    dom.setSelectionRange(dom.value.length,cursorPosition + (posLen || val.length));}/*光标所在位置插入字符*/insertAtCursor(dom, val) {    if (document.selection){        dom.focus();        sel = document.selection.createRange();        sel.text = val;        sel.select();    }else if (dom.selectionStart || dom.selectionStart == &apos;0&apos;){        let startPos = dom.selectionStart;        let endPos = dom.selectionEnd;        let restoreTop = dom.scrollTop;        dom.value = dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length);        if (restoreTop &gt; 0){            dom.scrollTop = restoreTop;        }        dom.focus();        dom.selectionStart = startPos + val.length;        dom.selectionEnd = startPos + val.length;    } else {        dom.value += val;        dom.focus();    }}</code></pre><blockquote><p>CSS</p></blockquote><h4 id="pc-reset-PC样式初始化"><a href="#pc-reset-PC样式初始化" class="headerlink" title="pc-reset PC样式初始化"></a>pc-reset PC样式初始化</h4><pre><code>/* normalize.css */html {line-height: 1.15;/* 1 */-ms-text-size-adjust: 100%;/* 2 */-webkit-text-size-adjust: 100%;/* 2 */}body {margin: 0;}article,aside,footer,header,nav,section {display: block;}h1 {font-size: 2em;margin: 0.67em 0;}figcaption,figure,main {/* 1 */display: block;}figure {margin: 1em 40px;}hr {box-sizing: content-box;/* 1 */height: 0;/* 1 */overflow: visible;/* 2 */}pre {font-family: monospace, monospace;/* 1 */font-size: 1em;/* 2 */}a {background-color: transparent;/* 1 */-webkit-text-decoration-skip: objects;/* 2 */}abbr[title] {border-bottom: none;/* 1 */text-decoration: underline;/* 2 */text-decoration: underline dotted;/* 2 */}b,strong {font-weight: inherit;}b,strong {font-weight: bolder;}code,kbd,samp {font-family: monospace, monospace;/* 1 */font-size: 1em;/* 2 */}dfn {font-style: italic;}mark {background-color: #ff0;color: #000;}small {font-size: 80%;}sub,sup {font-size: 75%;line-height: 0;position: relative;vertical-align: baseline;}sub {bottom: -0.25em;}sup {top: -0.5em;}audio,video {display: inline-block;}audio:not([controls]) {display: none;height: 0;}img {border-style: none;}svg:not(:root) {overflow: hidden;}button,input,optgroup,select,textarea {font-family: sans-serif;/* 1 */font-size: 100%;/* 1 */line-height: 1.15;/* 1 */margin: 0;/* 2 */}button,input {/* 1 */overflow: visible;}button,select {/* 1 */text-transform: none;}button,html [type=&quot;button&quot;],/* 1 */[type=&quot;reset&quot;],[type=&quot;submit&quot;] {-webkit-appearance: button;/* 2 */}button::-moz-focus-inner,[type=&quot;button&quot;]::-moz-focus-inner,[type=&quot;reset&quot;]::-moz-focus-inner,[type=&quot;submit&quot;]::-moz-focus-inner {border-style: none;padding: 0;}button:-moz-focusring,[type=&quot;button&quot;]:-moz-focusring,[type=&quot;reset&quot;]:-moz-focusring,[type=&quot;submit&quot;]:-moz-focusring {outline: 1px dotted ButtonText;}fieldset {padding: 0.35em 0.75em 0.625em;}legend {box-sizing: border-box;/* 1 */color: inherit;/* 2 */display: table;/* 1 */max-width: 100%;/* 1 */padding: 0;/* 3 */white-space: normal;/* 1 */}progress {display: inline-block;/* 1 */vertical-align: baseline;/* 2 */}textarea {overflow: auto;}[type=&quot;checkbox&quot;],[type=&quot;radio&quot;] {box-sizing: border-box;/* 1 */padding: 0;/* 2 */}[type=&quot;number&quot;]::-webkit-inner-spin-button,[type=&quot;number&quot;]::-webkit-outer-spin-button {height: auto;}[type=&quot;search&quot;] {-webkit-appearance: textfield;/* 1 */outline-offset: -2px;/* 2 */}[type=&quot;search&quot;]::-webkit-search-cancel-button,[type=&quot;search&quot;]::-webkit-search-decoration {-webkit-appearance: none;}::-webkit-file-upload-button {-webkit-appearance: button;/* 1 */font: inherit;/* 2 */}details,/* 1 */menu {display: block;}summary {display: list-item;}canvas {display: inline-block;}template {display: none;}[hidden] {display: none;}/* reset */html,body,h1,h2,h3,h4,h5,h6,div,dl,dt,dd,ul,ol,li,p,blockquote,pre,hr,figure,table,caption,th,td,form,fieldset,legend,input,button,textarea,menu {margin: 0;padding: 0;box-sizing: border-box;}</code></pre><h4 id="Phone-reset"><a href="#Phone-reset" class="headerlink" title="Phone-reset"></a>Phone-reset</h4><pre><code>/* normalize.css */html {line-height: 1.15;/* 1 */-ms-text-size-adjust: 100%;/* 2 */-webkit-text-size-adjust: 100%;/* 2 */}body {margin: 0;}article,aside,footer,header,nav,section {display: block;}h1 {font-size: 2em;margin: 0.67em 0;}figcaption,figure,main {/* 1 */display: block;}figure {margin: 1em 40px;}hr {box-sizing: content-box;/* 1 */height: 0;/* 1 */overflow: visible;/* 2 */}pre {font-family: monospace, monospace;/* 1 */font-size: 1em;/* 2 */}a {background-color: transparent;/* 1 */-webkit-text-decoration-skip: objects;/* 2 */}abbr[title] {border-bottom: none;/* 1 */text-decoration: underline;/* 2 */text-decoration: underline dotted;/* 2 */}b,strong {font-weight: inherit;}b,strong {font-weight: bolder;}code,kbd,samp {font-family: monospace, monospace;/* 1 */font-size: 1em;/* 2 */}dfn {font-style: italic;}mark {background-color: #ff0;color: #000;}small {font-size: 80%;}sub,sup {font-size: 75%;line-height: 0;position: relative;vertical-align: baseline;}sub {bottom: -0.25em;}sup {top: -0.5em;}audio,video {display: inline-block;}audio:not([controls]) {display: none;height: 0;}img {border-style: none;}svg:not(:root) {overflow: hidden;}button,input,optgroup,select,textarea {font-family: sans-serif;/* 1 */font-size: 100%;/* 1 */line-height: 1.15;/* 1 */margin: 0;/* 2 */}button,input {/* 1 */overflow: visible;}button,select {/* 1 */text-transform: none;}button,html [type=&quot;button&quot;],/* 1 */[type=&quot;reset&quot;],[type=&quot;submit&quot;] {-webkit-appearance: button;/* 2 */}button::-moz-focus-inner,[type=&quot;button&quot;]::-moz-focus-inner,[type=&quot;reset&quot;]::-moz-focus-inner,[type=&quot;submit&quot;]::-moz-focus-inner {border-style: none;padding: 0;}button:-moz-focusring,[type=&quot;button&quot;]:-moz-focusring,[type=&quot;reset&quot;]:-moz-focusring,[type=&quot;submit&quot;]:-moz-focusring {outline: 1px dotted ButtonText;}fieldset {padding: 0.35em 0.75em 0.625em;}legend {box-sizing: border-box;/* 1 */color: inherit;/* 2 */display: table;/* 1 */max-width: 100%;/* 1 */padding: 0;/* 3 */white-space: normal;/* 1 */}progress {display: inline-block;/* 1 */vertical-align: baseline;/* 2 */}textarea {overflow: auto;}[type=&quot;checkbox&quot;],[type=&quot;radio&quot;] {box-sizing: border-box;/* 1 */padding: 0;/* 2 */}[type=&quot;number&quot;]::-webkit-inner-spin-button,[type=&quot;number&quot;]::-webkit-outer-spin-button {height: auto;}[type=&quot;search&quot;] {-webkit-appearance: textfield;/* 1 */outline-offset: -2px;/* 2 */}[type=&quot;search&quot;]::-webkit-search-cancel-button,[type=&quot;search&quot;]::-webkit-search-decoration {-webkit-appearance: none;}::-webkit-file-upload-button {-webkit-appearance: button;/* 1 */font: inherit;/* 2 */}details,/* 1 */menu {display: block;}summary {display: list-item;}canvas {display: inline-block;}template {display: none;}[hidden] {display: none;}/* reset */html,body,h1,h2,h3,h4,h5,h6,div,dl,dt,dd,ul,ol,li,p,blockquote,pre,hr,figure,table,caption,th,td,form,fieldset,legend,input,button,textarea,menu {margin: 0;padding: 0;box-sizing: border-box;}html,body {/* 禁止选中文本 */-webkit-user-select: none;user-select: none;font: Oswald, &apos;Open Sans&apos;, Helvetica, Arial, sans-serif}/* 禁止长按链接与图片弹出菜单 */a,img {-webkit-touch-callout: none;}/*ios android去除自带阴影的样式*/a,input {-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}input[type=&quot;text&quot;] {-webkit-appearance: none;}</code></pre><h4 id="公共样式提取"><a href="#公共样式提取" class="headerlink" title="公共样式提取"></a>公共样式提取</h4><pre><code>/* 禁止选中文本 */.usn{    -webkit-user-select:none;    -moz-user-select:none;    -ms-user-select:none;    -o-user-select:none;    user-select:none;}/* 浮动 */.fl { float: left; }.fr { float: right; }.cf { zoom: 1; }.cf:after {    content:&quot;.&quot;;    display:block;    clear:both;    visibility:hidden;    height:0;    overflow:hidden;}/* 元素类型 */.db { display: block; }.dn { display: none; }.di { display: inline }.dib {display: inline-block;}.transparent { opacity: 0 }/*文字排版、颜色*/.f12 { font-size:12px }.f14 { font-size:14px }.f16 { font-size:16px }.f18 { font-size:18px }.f20 { font-size:20px }.fb { font-weight:bold }.fn { font-weight:normal }.t2 { text-indent:2em }.red,a.red { color:#cc0031 }.darkblue,a.darkblue { color:#039 }.gray,a.gray { color:#878787 }.lh150 { line-height:150% }.lh180 { line-height:180% }.lh200 { line-height:200% }.unl { text-decoration:underline; }.no_unl { text-decoration:none; }.tl { text-align: left; }.tc { text-align: center; }.tr { text-align: right; }.tj { text-align: justify; text-justify: inter-ideograph; }.wn { /* 强制不换行 */    word-wrap:normal;    white-space:nowrap;}.wb { /* 强制换行 */    white-space:normal;    word-wrap:break-word;    word-break:break-all;}.wp { /* 保持空白序列*/    overflow:hidden;text-align:left;white-space:pre-wrap;word-wrap:break-word;word-break:break-all;}.wes { /* 多出部分用省略号表示 , 用于一行 */    overflow:hidden;    word-wrap:normal;    white-space:nowrap;    text-overflow:ellipsis;}.wes-2 { /* 适用于webkit内核和移动端 */    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 2;    overflow: hidden;} .wes-3 {    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3;    overflow: hidden;}.wes-4 {    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 4;    overflow: hidden;}/* 溢出样式 */.ofh { overflow: hidden; }.ofs {overflow: scroll; }.ofa {overflow: auto; }.ofv {overflow: visible; }/* 定位方式 */.ps {position: static; }.pr {position: relative;zoom:1; }.pa {position: absolute; }.pf {position: fixed; }/* 垂直对齐方式 */.vt {vertical-align: top; }.vm {vertical-align: middle; }.vb {vertical-align: bottom; }/* 鼠标样式 */.csd {cursor: default; }.csp {cursor: pointer; }.csh {cursor: help; }.csm {cursor: move; }/* flex布局 */.df-sb {    display:flex;    align-items: center;    justify-content: space-between;}.df-sa {    display:flex;    align-items: center;    justify-content: space-around;}/* 垂直居中 */.df-c {    display: flex;    align-items: center;    justify-content: center;}.tb-c {    text-align:center;    display:table-cell;    vertical-align:middle;}.ts-c {    position: absolute;    left: 50%; top: 50%;    transform: translate(-50%, -50%);}.ts-mc {    position: absolute;    left: 0;right: 0;    bottom: 0; top: 0;    margin: auto;}/* 辅助 */.mask-fixed-wrapper {    width: 100%;    height: 100%;    position: fixed;    left:0;top:0;    background: rgba(0, 0, 0, 0.65);    z-index: 999;}.bg-cover {    background-size: cover;    background-repeat: no-repeat;    background-position: center center;}.bg-cover-all {    background-size: 100% 100%;    background-repeat: no-repeat;    background-position: center center;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;本文转载过来&lt;br&gt;作者：cd-dongzi&lt;br&gt;链接：&lt;a href=&quot;https://juejin.im/post/5a7523af5188257a7d6e028e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt.js学习</title>
    <link href="https://wyy511.top/frame/nuxt.html"/>
    <id>https://wyy511.top/frame/nuxt.html</id>
    <published>2018-05-16T03:10:10.000Z</published>
    <updated>2018-05-16T03:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h4 id="关于Nuxt-js"><a href="#关于Nuxt-js" class="headerlink" title="关于Nuxt.js"></a>关于Nuxt.js</h4><p>2016年10月25日，zeit.co背后的团队对外发布了Next.js，一个react的服务端渲染应用框架。几个小时后，与Next.js异曲同工，一个基于vue.js的服务端渲染应用框架应用而生，我们称之：Nuxt.js。</p><h4 id="Nuxt-js是什么？"><a href="#Nuxt-js是什么？" class="headerlink" title="Nuxt.js是什么？"></a>Nuxt.js是什么？</h4><p>Nuxt.js是一个基于vue.js的通用应用框架</p><p>通过对客户端/服务端基础架构的抽象组织，Nuxt.js只要关注的是应用的UI渲染</p><p>我们的目标是插件一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有的Node.js项目中使用Nuxt.js</p><p>Nuxt.js预设了利用vue.js开发服务端渲染的应用所需要的各种配置</p><p>除此之外，我们还提供了一种命令叫：nuxt generate，为基于vue.js的用用提供生成对应的静态站点的功能</p><p>我们相信这个命令所提供的功能，是向开发集成各种微服务的web应用迈开的新一步</p><p>作为框架，nuxt.js为客户端/服务端这种典型的应用框架模式提供了许多有用的特性，例如异步数据加载，中间件支持，布局支持等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;关于Nuxt-js&quot;&gt;&lt;a href=&quot;#关于Nuxt-js&quot; class=&quot;headerlink&quot; title=&quot;关于Nuxt.js&quot;&gt;&lt;/a&gt;关于Nuxt.js&lt;/h4&gt;&lt;p&gt;2016年10月25日，zeit.co背后的团队对外发布了N
      
    
    </summary>
    
    
      <category term="前端框架学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>node.js第一个应用</title>
    <link href="https://wyy511.top/node/node.js%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8.html"/>
    <id>https://wyy511.top/node/node.js的第一个应用.html</id>
    <published>2018-05-15T08:10:10.000Z</published>
    <updated>2018-05-28T09:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h4 id="什么是node-js？"><a href="#什么是node-js？" class="headerlink" title="什么是node.js？"></a>什么是node.js？</h4><blockquote><p>简单的说node.js就是运行在服务端的JavaScript<br>  node.js是一个基于chrome javascript 运行时建立的一个平台<br>  node.js是一个事件驱动I/O服务器JavaScript环境，基于Google的v8殷勤，v8殷勤执行JavaScript的速度非常快，性能非常好</p></blockquote><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><blockquote><p>node -v<br>  注意：不同版本间是有差异性的</p></blockquote><h4 id="第一个node-js程序：-hello-world"><a href="#第一个node-js程序：-hello-world" class="headerlink" title="第一个node.js程序： hello world!"></a>第一个node.js程序： hello world!</h4><blockquote><p>脚本模式<br>  console.log(“hello world!”);<br>  保存该文件，文件名为helloworld.js，并通过node命令来执行 node helloworld.js<br>  程序执行结果为 hello world!</p></blockquote><blockquote><p>交互模式<br>  打开终端，输入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果<br>  node<br>console.log(‘hello world!’)<br>  hello world!</p></blockquote><h4 id="创建node的第一个应用"><a href="#创建node的第一个应用" class="headerlink" title="创建node的第一个应用"></a>创建node的第一个应用</h4><blockquote><p>如果我们使用PHP来编写后端的代码时，需要Apache或者Nginx的http服务器，并配置mod_php5模块和php_cgi<br>  从这个角度看，整个接受http请求并提供web页面的需求根本不需要PHP来处理<br>  不过对node.js来说，概念就完全不一样了，使用node.js时，我们不仅仅在实现一个应用，同事还实现了整个http服务器<br>  事实上，我们的web应用以及对应的web服务器基本上是一致的<br>  在我们创建node的第一个程序“hello world!”应用前，让我们先了解下node.js应用由那几个部分组成</p></blockquote><p>  1.引入required模块：我们可以使用require指令来载入node.js模块<br>  2.穿件服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等http服务器<br>  3.接受请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接受请求后返回响应数据</p><h4 id="创建node-js应用"><a href="#创建node-js应用" class="headerlink" title="创建node.js应用"></a>创建node.js应用</h4><blockquote><p>步骤一：引入required模块</p></blockquote><p>我们使用require指令来载入http模块，并将实例化的http赋值给变量http</p><blockquote><p>var http = require(‘http’)</p></blockquote><blockquote><p>步骤二：创建服务器</p></blockquote><p>接下来我们使用http.createServer()方法创建服务器，并使用listen方法绑定8888端口。函数通过request、response参数来接收数据和响应数据<br>实例如下，在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码</p><pre><code>var http = require(&apos;http);http.createServer(function (request, response) {  // 发送http头部  // http状态值：200 : ok  // 内容类型：text/plain  response.writeHead(200, {    &apos;Content-Type&apos;: &apos;text/plain&apos;  })  // 发送响应数据“hello world”}).listen(8888)// 终端打印如下结果console.log(&apos;Server running at http://127.0.0.1:8888/&apos;)</code></pre><p>以上代码我们完成了一个可以工作的http服务器<br>使用node命令执行以上代码</p><blockquote><p>node server.js</p></blockquote><p>结果：Server running at <a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a></p><blockquote><p>分析：</p></blockquote><ul><li><p>第一行请求（require）node.js自带的http模块，并把它赋值给http变量</p></li><li><p>接下来我们调用http模块提供的函数：createServer，这个函数会返回一个对象，对象有个叫listen的方法，这个方法有个数值参数，指定这个http服务器监听的端口号</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是node-js？&quot;&gt;&lt;a href=&quot;#什么是node-js？&quot; class=&quot;headerlink&quot; title=&quot;什么是node.js？&quot;&gt;&lt;/a&gt;什么是node.js？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;简单的说node.
      
    
    </summary>
    
    
      <category term="node.js学习" scheme="https://wyy511.top/tags/node-js%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JS事件循环</title>
    <link href="https://wyy511.top/javascript/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"/>
    <id>https://wyy511.top/javascript/js事件循环.html</id>
    <published>2018-05-15T08:10:10.000Z</published>
    <updated>2018-05-16T03:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h4 id="一、为什么JS是单线程"><a href="#一、为什么JS是单线程" class="headerlink" title="一、为什么JS是单线程"></a>一、为什么JS是单线程</h4><pre><code>是由JS的用途决定的，其用途主要是与用户互动，以及操作DOM，如果不是单线程的话会带来很复杂的同步问题。比如：如果是多线程的话，一个用户新建一个DOM，另一个用户删除同一个DOM，该如何处理将变得非常麻烦。在html5中提出了web worker（todo 改天添加web worker的讲解）标准，JS可以创建多个线程或者是iframe，但是其他子线程主要是用来进行JS计算不能操作DOM，且受到子线程的控制。所以也并没有改变JS单线程的本质</code></pre><h4 id="二、同步和异步"><a href="#二、同步和异步" class="headerlink" title="二、同步和异步"></a>二、同步和异步</h4><pre><code>由于是单线程，所有任务需要排队，但是如果队列中所有的任务都是同步的话会造成资源的浪费。于是任务分为两类：同步任务和异步任务。异步任务的过程：    主线程（函数调用栈）发起一个异步请求，相应的工作线程接收请求，并告知主线程已经收到，主线程继续执行后面的同步代码，同时工作线程执行异步任务，工作线程完成工作后，通知主线程，主线程收到通知后，执行回调函数</code></pre><h4 id="三、宏任务和微任务"><a href="#三、宏任务和微任务" class="headerlink" title="三、宏任务和微任务"></a>三、宏任务和微任务</h4><pre><code>宏任务（micro-task）主要是：script代码段、setTimeout、setInterval、Promise的构造函数是同步的、setImmediate、I/O、UIrendering微任务（macro-task）主要是：Promise的回调、process.nextTick</code></pre><h4 id="四、任务队列和事件循环"><a href="#四、任务队列和事件循环" class="headerlink" title="四、任务队列和事件循环"></a>四、任务队列和事件循环</h4><pre><code>了解任务队列之前，先了解一下任务源，我们将发起异步任务的称之为任务源（setTimeout、Promise等），进入任务队列的是他们指定的任务。在一个线程中，事件循环是唯一的，任务队列是多个的。来自不同任务源的队列进入到不同的任务队列，setTimeout和setInterval是同源的</code></pre><h5 id="事件循环的步骤："><a href="#事件循环的步骤：" class="headerlink" title="事件循环的步骤："></a>事件循环的步骤：</h5><pre><code>1、运行主线程（函数调用栈）中的同步任务2、主线程（函数调用栈）执行到任务源时，通知相应的webAPIs进行相应的执行异步任务，将任务源指定的异步任务放入任务队列中3、主线程（函数调用栈）中的任务执行完毕后，然后执行所有的微任务，再执行宏任务，找到一个任务队列执行完毕，再执行所有的微任务4、不断执行第三步</code></pre><blockquote><p>事件循环：指主线程重复从任务队列中取消息，执行的过程</p></blockquote><p>先来一个简单的例子：</p><pre><code>setTimeout(() =&gt; {    console.log(&apos;begin&apos;)})new Promise((resolve) =&gt; {    console.log(&apos;promise begin&apos;)    for(let i = 0; i &lt; 1000; i++) {        i == 999 &amp;&amp; resolve()    }}).then(() =&gt; {    console.log(&apos;then begin&apos;)})console.log(&apos;end&apos;)</code></pre><p>因为promise的构造函数是同步的，promise.then是异步的微任务，所以promise beigin先于end<br>根据上面对宏任务和微任务的分析，其输出的情况为【promise begin——end——then begin——begin】<br>再来一个复杂点的，我们来一步一步的分析一个例子来看：</p><pre><code>console.log(&apos;golb1&apos;);setTimeout(function() {    console.log(&apos;timeout1&apos;);    process.nextTick(function() {        console.log(&apos;timeout1_nextTick&apos;);    })    new Promise(function(resolve) {        console.log(&apos;timeout1_promise&apos;);        resolve();    }).then(function() {        console.log(&apos;timeout1_then&apos;)    })})setImmediate(function() {    console.log(&apos;immediate1&apos;);    process.nextTick(function() {        console.log(&apos;immediate1_nextTick&apos;);    })    new Promise(function(resolve) {        console.log(&apos;immediate1_promise&apos;);        resolve();    }).then(function() {        console.log(&apos;immediate1_then&apos;)    })})process.nextTick(function() {    console.log(&apos;glob1_nextTick&apos;);})new Promise(function(resolve) {    console.log(&apos;glob1_promise&apos;);    resolve();}).then(function() {    console.log(&apos;glob1_then&apos;)})setTimeout(function() {    console.log(&apos;timeout2&apos;);    process.nextTick(function() {        console.log(&apos;timeout2_nextTick&apos;);    })    new Promise(function(resolve) {        console.log(&apos;timeout2_promise&apos;);        resolve();    }).then(function() {        console.log(&apos;timeout2_then&apos;)    })})process.nextTick(function() {    console.log(&apos;glob2_nextTick&apos;);})new Promise(function(resolve) {    console.log(&apos;glob2_promise&apos;);    resolve();}).then(function() {    console.log(&apos;glob2_then&apos;)})setImmediate(function() {    console.log(&apos;immediate2&apos;);    process.nextTick(function() {        console.log(&apos;immediate2_nextTick&apos;);    })    new Promise(function(resolve) {        console.log(&apos;immediate2_promise&apos;);        resolve();    }).then(function() {        console.log(&apos;immediate2_then&apos;)    })})</code></pre><p>一、第一步、首先执行宏任务script。全局入栈。输出glob1</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d563d442f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>二、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d8926f643?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>三、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d56422aa4?imageslim" alt=""></p><p>四、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d8eefb889?imageslim" alt=""></p><p>五、遇到Promise的构造函数，进入执行栈，输出glob1_promise，Promise.then()作为任务源，将指定的任务加入微任务</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d565af410?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>六、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d6135495e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>七、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d61da8ad8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>八、遇到Promise的构造函数，进入执行栈，输出glob2_promise，Promise.then()作为任务源，将指定的任务加入微任务</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d61c59908?imageslim" alt=""></p><p>九、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d82ecee97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>十、执行所有微任务队列，输出glob1_nextTick和glob2_nextTick、glob1_then、glob2_then</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/19/1623d52d83193a9d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><blockquote><p>事件机制其实就是异步任务的通知机制</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、为什么JS是单线程&quot;&gt;&lt;a href=&quot;#一、为什么JS是单线程&quot; class=&quot;headerlink&quot; title=&quot;一、为什么JS是单线程&quot;&gt;&lt;/a&gt;一、为什么JS是单线程&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;是由JS的用途决定的，其用途
      
    
    </summary>
    
    
      <category term="前端js学习" scheme="https://wyy511.top/tags/%E5%89%8D%E7%AB%AFjs%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://wyy511.top/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.html"/>
    <id>https://wyy511.top/我的第一篇文章.html</id>
    <published>2018-05-11T07:44:29.000Z</published>
    <updated>2018-05-11T09:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>第一自然段</p><p>第二自然段</p><p>注意：换行不是分段的标识，空行才是</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>注：# 和后续内容之间应放置一个空格</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>(1) 有序列表</p><ol><li><p>打开冰箱门</p></li><li><p>把大象放进冰箱</p></li><li><p>关上冰箱门</p></li></ol><p>(2) 无序列表</p><ul><li><p>吃饭</p></li><li><p>睡觉</p></li><li><p>打豆豆</p></li></ul><p>注意事项：</p><pre><code>无序列表的项目符号可使用 *,+,- 效果是相同的。列表与后续内容之间需要一个空行隔开，即：列表是一个段落列表允许多层次嵌套可以在项目中包含段落，只需将段落前添加一个 tab 或 4 个空格</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>语法：使用 3 个连续的 * 即可得到一个分割线</p><hr><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>语法：在行头加上 &gt; 即可。</p><blockquote><p>这里是一段引用</p></blockquote><pre><code>大于号 和 文字必须有一个空格可以在每行之前加 &gt; ，也可以在段落之前加 1 个 &gt;引用内部可以使用其他 Markdown 标记引用内部可以添加新的引用，只需再加一个大于号</code></pre><h3 id="行内标记"><a href="#行内标记" class="headerlink" title="行内标记"></a>行内标记</h3><p>(1) 强调文字</p><pre><code>斜体语法：使用前后各 1 个 *(或_) 包含的文字是 斜体 文字*斜体*, _斜体_粗体语法：使用前后各 2 个 *(或_) 包含的文字是 粗体 文字**粗体**，__粗体__删除文字语法：使用前后各 2 个 ~ 包含的文字是删除文字~~删除~~粗斜体语法：在**(或__)中嵌套_ (或*) 或 在_(或*)中嵌套**(或__)即可得到 粗斜体。_**粗斜体**_， *__粗斜体__***_粗斜体_**， __*粗斜体*__</code></pre><p>(2) 图片与链接</p><pre><code>1.图片：行内图片、引用图片    1&gt; 行内图片    图片和图片地址写在一起。    语法： ![图片标题](图片url)    ![史努比](http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="史努比"></p><pre><code>2&gt; 引用图片图片和图片地址分开书写。语法：![图片标题][图片id][图片id]:图片url![史努比][snoopy][snoopy]: http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="史努比"></p><pre><code>2. 链接：行内链接、链接引用、自动链接    1&gt; 行内链接    语法：[链接名称](链接地址 url &quot;链接title&quot;)    示例代码    [新浪](http://www.sina.com.cn &quot;新浪主页&quot;)</code></pre><p><a href="http://www.sina.com.cn" title="新浪主页" target="_blank" rel="noopener">新浪</a></p><pre><code>注意事项双引号中的内容是链接的 title (目前汉字显示不正确)    2&gt; 链接引用    一种链接和地址分离的方式。    [链接名称][链接id]    [链接id]:链接 url 地址 &quot;链接 title&quot;    示例代码    根据 [雅虎][yahoo] 的调查，希拉里将当选；根据 [谷歌][google] 的调查，川普将当选。    [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot;    [google]: http://google.com/ &quot;Google&quot;</code></pre><p>根据 <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">雅虎</a> 的调查，希拉里将当选；根据 <a href="http://google.com/" title="Google" target="_blank" rel="noopener">谷歌</a> 的调查，川普将当选。</p><pre><code>注意事项链接 id 可使用字母、数字、空格，但不区分大小写3.脚注 -- 为名词提供注释，注释将显示在文章末尾。语法：待解释文字[^脚注 id][^脚注 id]:注释内容示例代码Hello程序[^hello][^hello]:即：Hello, world 程序</code></pre><p>Hello程序[^hello]<br>[^hello]:即：Hello, world 程序</p><pre><code>注意事项脚注 id 必须唯一无论脚注 id 如何起名，显示时一律标为数字，并且按出现顺序排列</code></pre><h3 id="双标记"><a href="#双标记" class="headerlink" title="双标记"></a>双标记</h3><p>既可作为区块标记又可作为行内标记的标记。</p><ol><li><p>代码块</p><p> 1) 行内代码块<br> 语法：使用两个 ` 将代码包含起来</p><p> 示例代码</p><p> 在 Java 输出 Hello, world ：<code>System.out.print(&quot;Hello, World!&quot;);</code></p></li></ol><p>在 Java 输出 Hello, world ：<code>System.out.print(&quot;Hello, World!&quot;);</code></p><pre><code>2) 多行代码块语法：只需要每行都缩进 4 个空格即可，或者使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    示例代码 1 (行前4个空格)</span><br><span class="line"></span><br><span class="line">    // JQuery 的 Hello, world</span><br><span class="line">    $(function()&#123;</span><br><span class="line">    alert(&quot;Hello, world!&quot;)</span><br><span class="line">    &#125;);</span><br><span class="line">效果(行前4个空格)</span><br><span class="line"></span><br><span class="line">// JQuery 的 Hello, world</span><br><span class="line">$(function()&#123;</span><br><span class="line">    alert(&quot;Hello, world!&quot;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">示例代码 2 (```)</span><br></pre></td></tr></table></figure></code></pre><p>// JQuery 的 Hello, world<br>$(function(){<br>alert(“Hello, world!”)<br>});<br><code>`</code></p><p>效果 (<code>`</code>)</p><p>// JQuery 的 Hello, world<br>$(function(){<br>    alert(“Hello, world!”)<br>});<br>    注意事项：</p><pre><code>在代码区块内部，&quot;, &lt;&gt;,&amp; 将会自动转换为转义字符在代码区块内部，Markdown 标记将保持原样，即：星号(*)就是星号(*)，不被解释为特殊标记，这样就可以不能继续使用 Markdown 语法了</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法：</p><p>第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</p><p>列于列之间用管道符 | 隔开。表格每一行两边的管道符可省略。</p><p>第二行还可以为不同的列指定对齐方向。标题默认为居中对齐，内容默认为左对齐；在 - 左边加上 : 就是左对齐；在 - 右边加上 : 就是右对齐；在 - 两边都加上 : 就是居中对齐。</p><p>示例代码</p><pre><code>姓名|语文成绩|数学成绩|总成绩---|:---|:---:|---:喜羊羊|100|120|220</code></pre><table><thead><tr><th>姓名</th><th style="text-align:left">语文成绩</th><th style="text-align:center">数学成绩</th><th style="text-align:right">总成绩</th></tr></thead><tbody><tr><td>喜羊羊</td><td style="text-align:left">100</td><td style="text-align:center">120</td><td style="text-align:right">220</td></tr></tbody></table><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li>Markdown 与 HTML 的关系</li></ol><p>HTML 是一种发布的格式，Markdown 是一种书写的格式。</p><p>Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><p>在 Markdown 中可直接使用 HTML 标签，但需要注意</p><p>对于 HTML 区块元素――如 div、table、pre、p 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符(tab)或空格来缩进</p><p>HTML 的行内标签——如 span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用。</p><p>在 HTML 的区块标签中的 Markdown 标签是没有效果的</p><ol start="2"><li>特殊字符的自动转换</li></ol><p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp;，必须使用转义字符：&amp; lt ; 和 &amp; amp ;</p><p>Markdown 中，你可以自由的书写 &lt; 和 &amp;，编辑器会智能的进行判断：当这些符号用于 HTML 标签中，他们将保留原型；当他们单独使用时，将会转换为字符实体。</p><p>在代码块中，它们将统统被转换为字符实体，即：原样显示。</p><ol start="3"><li>Markdown 中的转义字符</li></ol><p>Markdown 中，如需显示有特定意义的符号，如：*,# 等，可使用 反斜杠 \ 进行转义。可对如下字符进行转义：</p><p>*</p><p>`</p><p>*<br>_</p><p>{}</p><p>()</p><p>#</p><p>+</p><p>-</p><p>.</p><p>!</p><p>作者：白老师课堂<br>链接：<a href="https://www.jianshu.com/p/4e3cae082b47" target="_blank" rel="noopener">https://www.jianshu.com/p/4e3cae082b47</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;段落&quot;&gt;&lt;a href=&quot;#段落&quot; class=&quot;headerlink&quot; title=&quot;段落&quot;&gt;&lt;/a&gt;段落&lt;/h3&gt;&lt;p&gt;第一自然段&lt;/p&gt;
&lt;p&gt;第二自然段&lt;/p&gt;
&lt;p&gt;注意：换行不是分段的标识，空行才是&lt;/p&gt;
&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="markdown 语法" scheme="https://wyy511.top/tags/markdown-%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wyy511.top/hello-world.html"/>
    <id>https://wyy511.top/hello-world.html</id>
    <published>2018-05-11T07:42:06.000Z</published>
    <updated>2018-05-11T07:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
