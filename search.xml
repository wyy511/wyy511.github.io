<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是webpack，为什么要使用它？]]></title>
    <url>%2Fjavascript%2F%E5%85%A5%E9%97%A8webpack.html</url>
    <content type="text"><![CDATA[转载文档：https://www.jianshu.com/p/d745b94ae920 什么是webpack webpack可以看做是模块打包机，它做的事情是分析你的项目结构，找到JavaScript模块以及其他的一些浏览器不能直接运行的拓展语言（scss，typescript等），并将其打包为合适的格式以供浏览器使用 为什么要使用webpack 今天很多网页可以看做是功能丰富的应用，它们拥有这复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 a:模块化，让我们可以把复杂的程序细化成小的文件 b:类似于typescript这种在JavaScript基础上拓展的开发语言，使我们能够事先目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别 c:scss,less等css预处理器 …… 这些改进确实大大的提高了我们的开发效率，但是利用他们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为webpack类的工具出现提供了需求 webpack和grunt以及glup相比有什么特性 其实webpack和另外两个并没有太多的可比性，gulp/grunt是一种能够优化前端的开发流程的工具，而webpack是一种模块化的解决方案，不过webpack的有点使得webpack可以替代glup/grunt类的工具 grunt和gulp的工作方式是，在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务 webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如index.js），webpack将从这个文件开始找到你的项目所有以来稳健，使用loaders处理他们，最后打包为一个浏览器可识别的javascript文件 优点：模块化 在webpack看来一切都是模块！这就是它不可不说的优点，包括你的JavaScript代码，也包括css和fonts以及图片等待，只有通过合适的loaders，他们都可以被当做模块被处理 1.css webpack提供两个工具处理样式表，css-loader和style-loader，两者处理的任务不同，css-loader使你能够使用类似@import和url(…)的方法实现require()的功能，style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的js文件中 需要分别安装：npm install style-loader css-loader –save-dev 2.css modules 在过去一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展的特别迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，且基于优化工具，依赖管理和加载管理可以自动完成 不过前端的另外一个部分，css发展就相对慢一些，大多的样式表却依旧是巨大且充满了全局类名，这使得维护和修改都非常困难和复制 最近一个叫做css modules技术就一在于把js的模块化思想带入css中来，通过css模块，所有的类名，动画名默认都只当作用于当前的模块。webpack从一开始就对css模块化提供了支持，在css loader中进行配置后，你说需要做的一些就是把modules传递到所需要的地方，然后就可以直接把css的类名传递到组件的代码中，且这样做值对当前组件有效，不必担心在不同的模块中具有相同类名可能会造成的问题，具体代码如下 这样相同的类名也不会相互污染 3.css预编译 sass和less之类的预处理器是对原生css的拓展，它们允许你使用类似于variables，nesting，mixins，inheritance等不存在与css中的特性来写css，css预处理器可以将这些特殊类型的语句转化为浏览器可识别的css语句 你现在可能都已经熟悉了，在webpack里使用相关的loader进行配置就可以使用了，一下是常用的css处理loader a:less-loader b:sass-loader c:stylus-loader 还有一个css处理平台postcss，可以让你用css实现更多功能，比如如何使用postcss，我们使用postcss来为css代码自动添加适应不同浏览器的css前缀 首先安装postcss-loader和autoprefixer（自动添加前缀的插件） npm install postcss-loader autoprefixer –save-dev 并在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件 webpack-pulgins插件（pulgins）是用来拓展webpack功能的，它们会在整个构建过程中生效，执行相关的任务 loader和pulgins常常被弄混，但是它们其实是完全不同的东西，可以这么说，loader是在打包构建过程中用来处理源文件的（jsx,scss,less），一次处理一个，插件并不是直接操作单个文件，它直接对整个构建过程起作用 webpack有很多内置的插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能 如何使用插件 要使用某个插件，我们需要通过npm安装它，然后要做的是在webpack配置中的pulgins关键字部分添加该插件的一个实例（plugins是一个数组），我们添加了一个实现版权声明的插件，如HtmlWebpackPlugin插件 该插件的作用是依据一个简单的模板，帮你生成最终的HTML5文件，这个文件中自动引用了你打包后的js文件，每次编译都在文件名中插入一个不同的哈希值 安装： npm install html-webpack-plugin –save-dev 本文已完，感谢您的阅读]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket.io学习]]></title>
    <url>%2Fsocketio%2Fsocket.io%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[转载文档：https://www.cnblogs.com/xiezhengcai/p/3956401.html 服务器 io.on(‘connection’, function(socket)); // 监听客户端返回连接，回调函数会传递本次连接的socket io.sockets.emit(‘String’, data); // 给所有客户端广播消息 io.sockets.socket(socketid).emit(‘String’, data); // 给指定的客户端发送消息 socket.on(‘String’, function(data)); // 监听客户端发送的消息 socket.emit(‘String’, data); // 给该socket的客户端发送消息 广播消息 给处理自己以为的客户端发送广播消息 socket.broadcast.emit(“msg”, {data: “hello, everyone”}); 给所有的客户端广播消息 io.sockets.emit(“msg”, {data: “Hello, all”}) 分组 socket.on(‘group1’, (data) =&gt; { socket.join(‘group1);})socket.on(‘group2’ (data) =&gt; { socket.join(‘group2);}) 客户端发送 socket.emit(‘group1’) // 就可以加入group1分组socket.emit(‘group2’) // 就可以加入group2分组 踢出分组 socket.leave(data.room) 对分组中的用户发送信息 不包括自己socket.broadcast.to(‘group1’).emit(‘event_name’, data);包括自己io.sockets.in(‘group1’).emit(‘event_name’, data); broadcast方法允许当前socket client不在该分组内 获取连接的客户端socket io.sockets.clients().forEach((socket) =&gt; { …}) 获取分组信息 获取所有房间（分组）信息io.sockets.manager.rooms来获取此socketid进入房间信息io.sockets.manager.roomClients[socket.id]获取particular room中的客户端，返回所有在此房间的socket实例io.sockets.clients(‘particular room’) 另一种分组方式 io.of(‘/some’).on(‘connection’, (socket) =&gt; { socket.on(‘test’, (data) =&gt; { socket.broadcast.emit(‘event_name’, {};) })}) 客户端 var socket = io.connect(‘ws://103.31.201.154:5555/some’) socket.on(‘event_name’, (data) =&gt; { console.log(data);}) 客户端都连接到ws://103.31.201.154:5555，但是服务器可以通过io.of(‘/some’)将其过滤出来 另外，socket.io提供了4个配置的API:io.configure, io.set, io.enable, io.disable.其中io.set对单项进行设置，io.enable和io.disable用户单项设置布尔型的配置。io.configure可以让你对不同的生产环境（如development和test等环境）配置不同的参数 客户端建立一个socket连接 var socket = io(‘ws://103.31.201.154:5555’); 监听服务消息 socket.io(‘msg’, (data) =&gt; { socket.emit(‘msg’, {rp: “fine, thank you”}); // 向服务器发送消息 console.log(data);}) socket.io(‘String’, function(data)) // 监听服务端发送的消息String参数与服务端emit低一个参数相同 监听socket断开与重连 socket.on(‘disconnect’, () =&gt; { console.log(‘与服务器断开’);}) socket.on(‘reconnect’, () =&gt; { console.log(‘重连到服务器’);}) 客户端socket.on()监听的事件 connect：连接成功 connecting：正在连接 disconnect：断开连接 connect_failed：连接失败 error：错误发生，并且无法被其他事件类型所处理 message：同服务器端message事件 anything：同服务器端anything事件 reconnect_failed：重连失败 reconnect：重连成功 reconnecting：正在重连 当第一次连接时，事件触发顺序为：connecting =&gt; connect; 当失去连接时，事件触发顺序为：disconnect =&gt; reconnecting（可能进行多次） =&gt; connecting =&gt; reconnect =&gt; connect 本文已完，感谢您的阅读]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js与React.js的全面对比]]></title>
    <url>%2Fframe%2Fvue-react.html</url>
    <content type="text"><![CDATA[转载文档：https://blog.csdn.net/CystalVon/article/details/78428036 Vue与React的对比 Vue.js与React.js从默写方面来说很相似，通过两个框架的学习，有时候对一些用法会有点思考，为加深歇息的思索，特从以下各方面进行了对比，加深了对两个框架的认知。 数据绑定Vue中有关数据绑定的部分 vue是双向绑定， Vue.js最核心的功能有两个，一是响应式的数据绑定系统，而是组件系统。所谓双向绑定，是vue实例中的data与其渲染的DOM元素内容一致，无论谁被改变，另一方会相应的更新为相同的数据，这是通过设置属性访问器实现的。 在vue中，与数据绑定有关的有插值表达式，指令系统，Class和Style，事件处理器和表单控件，ajax请求和计算属性 1.差值表达式 插值和指令又称模板语法 数据绑定最常见的形式就是使用“Mustache”语法（双大括号）的文本插值 Mustache语法不能作用在HTML特性上，遇到这种情况应该使用v-bind指令 2.指令 vue中的指令很方便，指令（Directives）是带有v-前缀的特殊属性。指令属性的值预期是个单个Javascript表达式（v-for是例外情况）指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于dom。 vue的12个指令：v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock 3.class与style绑定 数据绑定的一个常见需求是操作元素的class列表和它的内联样式。因为他们都是属性，我们可以用b-bind来处理他们、只需要计算出表达式最终的字符串，不过，字符串配件麻烦又易错，因此，在v-bind用于class和style时，vue.js专门增强了它，表达式的结果类型除了字符串之外，还可以是对象或数组。 对象语法 我们可以传给v-bind：class一个对象，以动态切换class 数组语法 我们可以把一个数组传给v-bind:class，以应用一个class列表 v-bind:class=”[activeClass, errorClass]” 4.条件渲染和列表渲染 v-if条件渲染数组 我们用v-for指令根据数组的选项列表进行渲染，v-for指令需要使用item in items形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。 5.事件处理器 通过v-on给元素注册事件 使用v-on有几个好处 扫一眼HTML模板能轻松定位在JavaScript代码里应对的方法 因为你无需在JavaScript里手动绑定事件，你的viewmodel代码可以是非常纯粹的逻辑，和dom完全耦合，更易于测试 当一个viewmodel被销毁时，所有的事件处理器会自动被消除，你无需担心去和自己清理他们 6.表单控件 v-model在表单控件元素上创建双向数据绑定 它会根据控件类型自动选取正确的方式来更新元素 7.计算属性 在vue中引入了计算属性来处理模板中放入太多的逻辑会让模板过重而难以为维护的问题，这样不当解决了上面的问题，而且也同时让模板和业务逻辑更好的分离 简单来说，加入data里面有属性a=1，然后你需要一个变量跟着a变化，例如b=a+1,那么就需要用到计算属性，vue实例的computed睡醒中设置b为其属性，其表现为一个函数，返回的是b的值 8.ajax请求 vue2.0中数据请求推荐使用axios 注：关于vue数据的双向绑定和单向数据流 vue的依赖追踪是【原理上不支持双向绑定，v-model只是通过监听dom时间实现的语法糖】 vue的依赖追踪是通过Object.defineProperty，把data对象的属性全部转为getter/setter来实现的，当改变数据的某个属性时，会触发set函数，获取该属性值的时候会粗发get函数，通过这个特性来实现改变数据时改变视图，也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过dom时间来改变数据，再由此来改变属兔，以此来双向绑定 双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联 组件之间的通信采用单向数据流是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以vue不推荐子组件修改不着急的数据，直接修改props会抛出警告 react没有数据双向绑定 react是单向数据流 react中通过将state（model层）与view层数据进行双向绑定大数据的实时变化更新，具体来说就是在view层直接写js代码，model层中的数据拿过来渲染，一旦像表单操作，触发时间，ajax请求等触发数据变化，则进行双同步 1.事件处理 react元素的事件处理和DOM元素很相似，但是有一点点语法上不同 react时间绑定属性的命名采用驼峰式写法，而不是小写 如果采用jsx的语法你需要传入一个函数作为时间处理函数，而不是一个字符串（DOM元素的写法） 在React中另一个不同时你不能使用返回false的方式阻止默认行为，你必须明确的使用preventDefault 当你使用ES6 class语法来顶一个组件的时候，事件处理器会成为类的一个方法，一般需要显式的绑定this，例如 this.handleClick = this.handleClick.bind(this) 你必须谨慎对待jsx回调函数中的this，类的方法默认是不会绑定this的，如果你忘记绑定this.handleClick并把它传入onClick，当你调用这个函数的时候this的值会是undefined 2.条件渲染 react中的条件渲染和JavaScript中的一致，使用JavaScript操作符if或者条件运算来创建标识当前状态的元素，然后让react根据它们来更新UI 你可以通过使用花括号包裹代码在jsx中嵌入任何表达式，也包括JavaScript的逻辑与&amp;&amp;，它可以方便的条件渲染一个元素，之所以能这样做，是因为JavaScript中，true&amp;&amp;expression总是返回expression，而false&amp;&amp;expression总是返回false，因此，如果条件是true，&amp;&amp;右侧的元素就会被渲染，如果是false，react会忽略跳过它 条件渲染的另一种方式是使用JavaScript的条件运算符condition？true：false 3.列表渲染 你可以通过使用{}在jsx内构建一个元素集合，使用JavaScript的map（）方法遍历数组 keys可以在DOM中的某些元素被增加或删除的时候帮助react识别哪些元素发生了变化，因此你应当给数组中的每个元素赋予一个确定的标识，一个元素的可以最好是这个元素在列表中拥有的一个独一无二的字符串，通常，我们使用来自数据的id作为元素的key 4.表单操作 HTML表单元素与react中的其他dom元素有所不同，因为表单元素生来就保留一些内部状态 当用户提交表单时，HTML的默认行为就会使这个表单跳到一个新页面，在react中也是如此。但大多数情况下，我们会构建一个处理提交表单并可以防卫用户输入表单数据的函数，实现这一点的标准方法是使用一种称为“受控组件”的技术，其值由react控制的输入表单元素称为“受控组件”，this.setState({value: event.target.value}) 当你有处理多个受控的input元素时，你可以通过给每个元素加上name属性，来处理函数event.target.name的值来选择做什么 5.状态提升 在react中，状态分享是通过将state数据提升到离这些数据的组件最近的父组件来完成的，这就是所谓的状态提升，this.props.xxx 在react应哟领中，对用任何可变数据理应只有一个单一的“数据源”，通常，状态都是首先添加在需要渲染的组件中，此时，如果另一个组件也需要这些数据，你可以将数据提升至他们最近的父组件中，你应该在应用中保持自上而下的数据流，而不是尝试在不同组件中同步状态 组件化以及组件数据流react中的组件及数据流 react是单向数据流，数据主要从父节点传递到子节点（通过props），如果顶层（父级）的某个props改变了，react会重新渲染所有的子节点 react中实现组件的方式有两种，一种是createClass方法，另一种是通过ES2015的思想类继承React Component来实现 在react中，按钮，表单，对话框，整个屏幕的内容等，这些通常都被标识为组件 react推崇的是函数式编程和单向数据流，给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新） 组件可以将UI切成一些独立的，可复用的部件，这样你就只需要专注于构建每个单独的部件，组件从概念上看就像是函数，它可以接受任意的输入值（称为props），并返回一个需要在页面上展示的react元素 1.props的只读性 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props 所有的react组件必须像纯函数那样使用他们的props props与state的区别 props是property的缩写，可以理解为HTML标签的attribute，不可以使用this.props直接修改props，因为props是只读的，props是用于整个组件树中传递数据和配置，在当前组件防卫props，使用this.props props是一个组件的设置参数，可以在父组件中选择性设置，父组件对子组件的props进行复制，并且props的值不可以改变，一个子组件自身不能改变自己的props state：当一个组件mounts时，state如果设置有默认值的会被使用，并且state可能时刻的被改变，一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子组件的state，所以可以认为，state是子控件自身私有的 每个组件都有属于自己的state，state和props的区别在于前者（state）值存在于组件内部，只能从当前组件调用this.setState修改state值（不可以直接修改this.state）-props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中，然而state代表的是子组件自身的内部状态。从语义上将，改变组件的状态，可能会导致DOM结构的改变或者重新渲染，而props是父组件传递的参数，所以可以被用于初始化渲染和改变数组自身的状态，虽然大多数时候组件的状态是从外部事件触发改变的，我们需要知道的是，无论是state改版，还是父组件传递的props改变，render方法都可能被执行-一般我们更新子组件都是通过改变state的值，更新子组件的props值从而达到更新 2.组件之间的通信 父子组件数通信 * 父与子之间痛props属性进行传递 * 父与子之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信 即： 父组件更新组件状态 –props– 子组件更新 子组件更新父组件状态 –需要父组件传递回调函数– 子组件调用触发 非父组件之间的通信，嵌套不慎的非父子组件可以使用共同父组件，触发时间函数传形参的方式来实现 按照react单向数据流方式，我们需要借助父组件来进行传递，通过父组件回调函数改变兄弟组件的props，其实这种实现方式与子组件更新父组件状态的方式是大同小异的 当组件层次很深的时候，在这里， react官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层的传递到子组件中 3.组件的生命周期 construtor() //创建组件 componentWillMount() //组件挂载之前 componentDidMount() // 组件挂载之后 componentWillReceiveProps() // 父组件发生render的时候子组件调用该函数 shouldComponentUpdate() // 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回true componentDidUpdate() // 更新 render() //渲染，react中的核心函数 componentWillUnmount() //组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除 vue中的组件及数据流1.组件化应用构建 组件系统是vue的另一个重要概念，因为它是一种抽象，允许我们使用小型，独立和通常可复现的组件构建大型应用 在vue中，一个组件本质上是一个拥有预定义选项的一个vue实例 在一个大型项目中，有必要将整个应用程序划分成组件，以使开发可管理 组件是vue最强大的功能之一，组件可以帮助你扩展基本的HTML元素，以封装可重用的代码，在较高层面上，组件是vue编译器附加香味后的自定义元素，在某些情况下，组件也可以是原生HTML元素的形式，以特定的js特性扩展 组件中，data必须是一个函数 组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义的元素，vue的编译器为它添加特殊功能，在有些情况下，组件也可以是原生HTML元素的形式，以js特性扩展 2.响应式 当一个vue实例被创建时，它向vue的响应式系统中加入了其data对象中能找到的所有属性，当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值 当这些数据改变时，视图会重新渲染。值得注意的是只有当实例被创建时，data中存在的属性是响应式的 3.组件的生命周期 每个vue实例在被创建时都要经过一系列的初始化。例如需要设置数据监听，编译模板，挂载实例到DOM，在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码 比如created钩子可以用来在一个实例被创建之后执行代码，也有一些其他的钩子，在实例生命周期的不同场景下使用，如mounted,updated,destoryed。钩子的this指向调用它的vue实例 生命周期图示 4.组件之间的通信 vue默认的是单向数据流，这是vue直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了 vue也支持双向绑定，默认为单向绑定，数据从父组件单向传递给子组件。在大型应用中使用单向绑定让数据流更易于理解 父子组件的数据通信时通过props和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于angular中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（vuex） 在vue中，父子组件之间的关系可以概述为：props向下，events向上。父组件通过props向下传递数据给子组件，子组件通过events发送信息给父组件 父向子 每个组件实例都有自己的孤立隔离的作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用props将数据向下传递到子组件 每个props属性，都可以控制是否从父组件的自定义属性中接受数据，子组件需要使用props选项显示声明props，以便它可以从父组件接收到期望的数据 动态props，类似于将一个普通属性绑定到一个表达式，我们还可以使用v-bind将props属性动态的绑定到父组件中的数据。无论父组件何时更新，都可以讲数据向下流入到子组件中 子向父 使用自定义事件 每个vue实例都介入了一个事件接口，也就是说，这些vue实例可以做到 使用on监听一个事件，使用emit触发一个事件 非父子组件通信 可以使用一个空的vue实例作为一个事件总线中心，用emit触发事件，on监听事件 后续未完&gt;&gt;&gt;&gt;&gt;]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG.js学习]]></title>
    <url>%2Fframe%2Fsvg.html</url>
    <content type="text"><![CDATA[SVG.js SVG 是英文 Scalable Vector Graphics 的缩写，意为可缩放矢量图。 SVG 是用XML格式定义的矢量图。 SVG 1.0 诞生于2001年9月4日 SVG 表示可缩放矢量图 SVG 用来定义WEB上使用的矢量图 SVG 用XML格式定义矢量图 SVG 在缩放时不会损失任何的图片质量 SVG 文件里的所有元素和属性都可以运用动画效果 SVG 是W3C推荐的 SVG 集成了其它W3C标准，比如 DOM 和 XSL SVG 的优势 SVG 图片可以使用文本编辑器创建和编辑 SVG 图片能够实现内容搜索，索引，脚本控制和压缩 SVG 图片是可缩放的 SVG 图片可以以任意高分辨率打印 SVG 图片的缩放显示是无损的 SVG 是开放标准 SVG 文件是纯XML的 SVG的最大竞争者是Flash。 SVG的优势体现在，它兼容了其它标准(比如，XSL和DOM)。Flash是具有专利的技术，不开源。 创建 SVG 图片 SVG 图片可以使用任何文本编辑器创建，但更高效的还是一些专业绘图软件，比如 Inkscape. SVG和HTML5 在HTML5里，我们可以直接在html网页里嵌入/使用SVG。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;My first SVG&lt;/h1&gt; &lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;green&quot; stroke-width=&quot;4&quot; fill=&quot;yellow&quot;/&gt; &lt;/svg&gt; &lt;/body&gt; &lt;/html&gt; SVG代码说明： SVG图片用&lt;svg&gt;标记定义 &lt;svg&gt;元素里提供了“width”和“height”两个属性来定义SVG图片的高度和宽度 &lt;circle&gt;元素的功能是画出一个圆 cx和cy两个属性分别定义了圆心的x坐标和y坐标。如果没有提供cx和cy的值，那么，缺省圆心是(0, 0) r属性定义了圆的半径长度 stroke和stroke-width两个属性用来定义图像的边框样子。上面例子中定义圆的边框颜色为green，边框粗细为4px fill属性定义了圆内部填充的颜色。我们可以看出，例子中填充了黄色。 注意：因为SVG是XML格式的，所以，所有元素标记必须正确的闭合。 SVG基础图形 SVG形状 SVG里预定义里一些形状，程序员可以使用这些元素来绘制图形： 矩形 圆形 椭圆 直线 折线 多边形 路径 SVG矩形 rect用来绘制一个矩形，以及类似图形，比如长方形，正方形等。 例 1 &lt;svg width=&quot;400&quot; height=&quot;110&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)&quot; /&gt; &lt;/svg&gt; 代码说明： &lt;rect&gt;元素里的width和width属性定义了矩形的高度和宽度 style属性定义了这个矩形的CSS属性。 style属性里的fill属性定义了这个矩形填充的颜色 style属性里的stroke-width属性定义了矩形边线的宽度 style属性里的stroke属性定义了矩形的边线的颜色 例 2 &lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot; style=&quot;fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9&quot;/&gt; &lt;/svg&gt; 代码说明： x属性定义矩形距离左边的距离，比如，x=&quot;50&quot;相对于CSS里的margin-left: 50px y属性定义了矩形距离上边的距离，比如y=&quot;20&quot;相当于CSS里的margin-top: 20px CSS fill-opacity属性定义了填充颜色的透明度，值范围为 0 到 1 CSS stroke-opacity属性定义了边线颜色的透明度，值范围为 0 到 1 例 3 &lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot; style=&quot;fill:blue;stroke:pink;stroke-width:5;opacity:0.5&quot; /&gt; &lt;/svg&gt; 代码说明： CSS opacity属性定义了整个图形元素的透明度 例 4 &lt;svg width=&quot;400&quot; height=&quot;180&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;150&quot; height=&quot;150&quot; style=&quot;fill:red;stroke:black;stroke-width:5;opacity:0.5&quot; /&gt; &lt;/svg&gt; 代码说明： rx和ry定义了矩形四个角的圆角效果 SVG圆形 circle元素的作用是绘制圆形： &lt;svg height=&quot;100&quot; width=&quot;100&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;red&quot; /&gt; &lt;/svg&gt; 代码说明： cx和cy属性是用来定义圆心的坐标。如果没有提供cx和cy的值，则缺省圆心是(0,0) r属性定义了圆的半径长度 SVG椭圆 ellipse元素的作用是绘制一个椭圆。 椭圆跟圆形很相似。不同之处在于椭圆有两个半径，并且这两个值不同，而圆形也可以说有两个半径，但两个值是相同的： 例 1 &lt;svg height=&quot;140&quot; width=&quot;500&quot;&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;fill:yellow;stroke:purple;stroke-width:2&quot; /&gt; &lt;/svg&gt; 代码说明： cx属性定义了椭圆的x坐标 cy属性定义了椭圆的y坐标 rx属性定义了椭圆的横向半径 ry属性定义了椭圆的纵向半径 例 2 &lt;svg height=&quot;150&quot; width=&quot;500&quot;&gt; &lt;ellipse cx=&quot;240&quot; cy=&quot;100&quot; rx=&quot;220&quot; ry=&quot;30&quot; style=&quot;fill:purple&quot; /&gt; &lt;ellipse cx=&quot;220&quot; cy=&quot;70&quot; rx=&quot;190&quot; ry=&quot;20&quot; style=&quot;fill:lime&quot; /&gt; &lt;ellipse cx=&quot;210&quot; cy=&quot;45&quot; rx=&quot;170&quot; ry=&quot;15&quot; style=&quot;fill:yellow&quot; /&gt; &lt;/svg&gt; 例 3 &lt;svg height=&quot;100&quot; width=&quot;500&quot;&gt; &lt;ellipse cx=&quot;240&quot; cy=&quot;50&quot; rx=&quot;220&quot; ry=&quot;30&quot; style=&quot;fill:yellow&quot; /&gt; &lt;ellipse cx=&quot;220&quot; cy=&quot;50&quot; rx=&quot;190&quot; ry=&quot;20&quot; style=&quot;fill:white&quot; /&gt; &lt;/svg&gt; ##### line元素可以用来画出一条直线： &lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot; /&gt; &lt;/svg&gt; 代码说明： x1属性定义了直线的x轴起始坐标 y1属性定义了直线的y轴起始坐标 x2属性定义了直线的x轴终止坐标 y2属性定义了直线的y轴终止坐标 SVG折线 元素用来绘制各种各样的折线： 例 1 &lt;svg height=&quot;200&quot; width=&quot;500&quot;&gt; &lt;polyline points=&quot;20,20 40,25 60,40 80,120 120,140 200,180&quot; style=&quot;fill:none;stroke:black;stroke-width:3&quot; /&gt; &lt;/svg&gt; 例 2 &lt;svg height=&quot;180&quot; width=&quot;500&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt; &lt;/svg&gt; 代码说明： points属性里定义了各个点的坐标，x和y坐标之间用逗号分别，多个坐标之间用空格分割 SVG多边形 polygon元素用来绘制多边形图形，比如三角形，四边形，五边形等。 多边形是直线围成的图形。 多边形的英文单词是Polygon，来自希腊，”Poly”的意思是”many”，而 “gon” 的意思是 “angle”。 例 1 下面的是用SVG绘制的三角形： &lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;200,10 250,190 160,210&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot; /&gt; &lt;/svg&gt; 代码说明： points属性里定义了多边形各个角的x和y坐标，多个坐标间用空格分隔 例 2 下面是一个四边形： &lt;svg height=&quot;250&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;220,10 300,210 170,250 123,234&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot; /&gt; &lt;/svg&gt; 例 3 下面我们用 polygon 元素创建一个五角星： &lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; /&gt; &lt;/svg&gt; 例 4 使用fill-rule: evenodd属性： &lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt; &lt;/svg&gt; SVG路径 path元素可以用来定义一个路径。 指令 参数 名称 描述 M x,y moveto移动到 移动虚拟画笔到指定的（x,y）坐标，仅移动不绘制 m x,y moveto 同M，但使用相对坐标 L x,y lineto连直线到 从当前画笔所在位置绘制一条直线到指定的（x,y）坐标 l x,y lineto 同L，但使用相对坐标 H x horizontal lineto水平连线到 绘制一条水平直线到参数指定的x坐标点，y坐标为画笔的y坐标 h x horizontal lineto 同H，但使用相对坐标 V y vertical lineto垂直连线到 从当前位置绘制一条垂直直线到参数指定的y坐标 v y vertical lineto 同V，但使用相对坐标 C x1,y1 x2,y2 x,y curveto三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝兹曲线到参数（x,y）指定的坐标。x1，y1和x2,y2是曲线,开始和结束控制点，用于控制曲线的弧度 c x1,y1 x2,y2 x,y curveto 同C，但使用相对坐标 S x2,y2 x,y shorthand / 平滑三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝塞尔曲线到参数（x,y）指定的坐标。x2,y2是结束控制点.开始控制点和前一条曲线的结束控制点相同 s x2,y2 x,y shorthand / 平滑三次方贝塞尔曲线 同S，但使用相对坐标 Q x1,y1 x,y 二次方贝塞尔曲线 从当前画笔位置绘制一条二次方贝塞尔曲线到参数（x,y）指定的坐标。x1,y1是控制点，用于控制曲线的弧度 q x1,y1 x,y 二次方贝塞尔曲线 同Q，但使用相对坐标 T x,y 平滑的二次贝塞尔曲线 从当前画笔位置绘制一条二次贝塞尔曲线到参数（x,y）指定的坐标。控制点被假定为最后一次使用的控制点 t x,y 平滑的二次贝塞尔曲线 同T，但使用相对坐标 A rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 从当前画笔位置开始绘制一条椭圆弧线到（x,y）指定的坐标。rx和ry分别为椭圆弧线水平和垂直方向上的半径。x-axis-rotation指定弧线绕x轴旋转的度数。它只在rx和ry的值不相同是有效果。large-arc-flag是大弧标志位，取值0或1，用于决定绘制大弧还是小弧。sweep-flag用于决定弧线绘制的方向 a rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 同A，但使用相对坐标 Z 无 闭合路径 从结束点绘制一条直线到开始点，闭合路径 z 无 闭合路径 同Z 注意:所有的这些字符命令都可以用大小写两种形式。大小表示绝对位置，而小写表示相对位置。 例 1 &lt;svg height=&quot;210&quot; width=&quot;400&quot;&gt; &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt; &lt;/svg&gt; 例 2 贝塞尔曲线是一种非常顺滑的曲线。通常，用户需要提供两个端点和一个或两个控制点。使用一个控制点的贝塞尔曲线叫做二次方贝塞尔曲线，使用两个控制点的贝塞尔曲线叫做三次方贝塞尔曲线。 &lt;svg height=&quot;400&quot; width=&quot;450&quot;&gt; &lt;path id=&quot;lineAB&quot; d=&quot;M 100 350 l 150 -300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path id=&quot;lineBC&quot; d=&quot;M 250 50 l 150 300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;!-- Mark relevant points --&gt; &lt;g stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;black&quot;&gt; &lt;circle id=&quot;pointA&quot; cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointB&quot; cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointC&quot; cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;/g&gt; &lt;!-- Label the points --&gt; &lt;g font-size=&quot;30&quot; font-family=&quot;sans-serif&quot; fill=&quot;black&quot; stroke=&quot;none&quot; text-anchor=&quot;middle&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;350&quot; dx=&quot;-30&quot;&gt;A&lt;/text&gt; &lt;text x=&quot;250&quot; y=&quot;50&quot; dy=&quot;-10&quot;&gt;B&lt;/text&gt; &lt;text x=&quot;400&quot; y=&quot;350&quot; dx=&quot;30&quot;&gt;C&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; SVG clipPath clipPath标记的作用相当于一个蒙版，它能限制哪些地方可见，哪些地方不可见。标记指定的区域之外的所有内 容都不会被显示(图像不会被绘制出来). clipPath元素需要使用clip-path属性来引用。 转载svg文档：http://know.webhek.com/svg/svg-polygon.html https://www.banber.com/banber/5b150dace79d6359cea7a93d.html]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序（applet of WeChat）]]></title>
    <url>%2Fweixin%2Fwechat-progress.html</url>
    <content type="text"><![CDATA[什么是微信小程序 微信小程序，简称小程序，是一种不需要下载安装就可以使用的应用程序，它实现了应用“触手可及”的梦想，用户扫一扫或搜索就可以打开应用 特点： 免安装，操作更接近原生APP，必须是在微信中打开 小程序有哪些宣传方式 小程序搜索入口 附近的小程序 扫一扫，长按识别小程序码 好友分享，群分享 关联公众号 第三方的小程序应用商店 小程序之间可以互相跳转 小程序开发流程注册小程序 — 代码开发 — 提审 — 上线 如何注册小程序 通过公众号注册 进入微信小程序官网注册 https://mp.weixin.qq.com/ 代码结构 page的生命周期配置：https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax学习]]></title>
    <url>%2Fjavascript%2Fajax.html</url>
    <content type="text"><![CDATA[AJAX概念 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX 不是新的编程语言，而是一种使用现有标准的新方法。AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 什么是 AJAX ？AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 Google Suggest在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 AJAX - 创建 XMLHttpRequest 对象 XMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 对象 所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 创建 XMLHttpRequest 对象 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象的语法： variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }]]></content>
      <tags>
        <tag>前端js学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具类的封装（javascript）]]></title>
    <url>%2Fjavascript%2Fjs%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B0%81%E8%A3%85.html</url>
    <content type="text"><![CDATA[本文转载过来作者：cd-dongzi链接：https://juejin.im/post/5a7523af5188257a7d6e028e来源：掘金 在工作中经常用到这些工具类的封装 Javascript type 类型判断isString (o) { //是否字符串 return Object.prototype.toString.call(o).slice(8, -1) === &apos;String&apos; } isNumber (o) { //是否数字 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Number&apos; } isBoolean (o) { //是否boolean return Object.prototype.toString.call(o).slice(8, -1) === &apos;Boolean&apos; } isFunction (o) { //是否函数 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Function&apos; } isNull (o) { //是否为null return Object.prototype.toString.call(o).slice(8, -1) === &apos;Null&apos; } isUndefined (o) { //是否undefined return Object.prototype.toString.call(o).slice(8, -1) === &apos;Undefined&apos; } isObj (o) { //是否对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Object&apos; } isArray (o) { //是否数组 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Array&apos; } isDate (o) { //是否时间 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Date&apos; } isRegExp (o) { //是否正则 return Object.prototype.toString.call(o).slice(8, -1) === &apos;RegExp&apos; } isError (o) { //是否错误对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Error&apos; } isSymbol (o) { //是否Symbol函数 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Symbol&apos; } isPromise (o) { //是否Promise对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Promise&apos; } isSet (o) { //是否Set对象 return Object.prototype.toString.call(o).slice(8, -1) === &apos;Set&apos; } isFalse (o) { if (!o || o === &apos;null&apos; || o === &apos;undefined&apos; || o === &apos;false&apos; || o === &apos;NaN&apos;) return true return false } isTrue (o) { return !this.isFalse(o) } isIos () { var u = navigator.userAgent; if (u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1) {//安卓手机 // return &quot;Android&quot;; return false } else if (u.indexOf(&apos;iPhone&apos;) &gt; -1) {//苹果手机 // return &quot;iPhone&quot;; return true } else if (u.indexOf(&apos;iPad&apos;) &gt; -1) {//iPad // return &quot;iPad&quot;; return false } else if (u.indexOf(&apos;Windows Phone&apos;) &gt; -1) {//winphone手机 // return &quot;Windows Phone&quot;; return false }else{ return false } } isPC () { //是否为PC端 var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) &gt; 0) { flag = false; break; } } return flag; } browserType(){ var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isIE11 = userAgent.indexOf(&apos;Trident&apos;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1; var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器 var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器 var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器 var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器 if (isIE) { var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) return &quot;IE7&quot; else if(fIEVersion == 8) return &quot;IE8&quot;; else if(fIEVersion == 9) return &quot;IE9&quot;; else if(fIEVersion == 10) return &quot;IE10&quot;; else return &quot;IE7以下&quot;//IE版本过低 } if (isIE11) return &apos;IE11&apos;; if (isEdge) return &quot;Edge&quot;; if (isFF) return &quot;FF&quot;; if (isOpera) return &quot;Opera&quot;; if (isSafari) return &quot;Safari&quot;; if (isChrome) return &quot;Chrome&quot;; } checkStr (str, type) { switch (type) { case &apos;phone&apos;: //手机号码 return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str); case &apos;tel&apos;: //座机 return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str); case &apos;card&apos;: //身份证 return /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test(str); case &apos;pwd&apos;: //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\w{5,17}$/.test(str) case &apos;postal&apos;: //邮政编码 return /[1-9]\d{5}(?!\d)/.test(str); case &apos;QQ&apos;: //QQ号 return /^[1-9][0-9]{4,9}$/.test(str); case &apos;email&apos;: //邮箱 return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case &apos;money&apos;: //金额(小数点2位) return /^\d*(?:\.\d{0,2})?$/.test(str); case &apos;URL&apos;: //网址 return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str) case &apos;IP&apos;: //IP return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str); case &apos;date&apos;: //日期时间 return /^(\d{4})\-(\d{2})\-(\d{2}) (\d{2})(?:\:\d{2}|:(\d{2}):(\d{2}))$/.test(str) || /^(\d{4})\-(\d{2})\-(\d{2})$/.test(str) case &apos;number&apos;: //数字 return /^[0-9]$/.test(str); case &apos;english&apos;: //英文 return /^[a-zA-Z]+$/.test(str); case &apos;chinese&apos;: //中文 return /^[\u4E00-\u9FA5]+$/.test(str); case &apos;lower&apos;: //小写 return /^[a-z]+$/.test(str); case &apos;upper&apos;: //大写 return /^[A-Z]+$/.test(str); case &apos;HTML&apos;: //HTML标记 return /&lt;(&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*&gt;/.test(str); default: return true; } // 严格的身份证校验 isCardID(sId) { if (!/(^\d{15}$)|(^\d{17}(\d|X|x)$)/.test(sId)) { alert(&apos;你输入的身份证长度或格式错误&apos;) return false } //身份证城市 var aCity={11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;}; if(!aCity[parseInt(sId.substr(0,2))]) { alert(&apos;你的身份证地区非法&apos;) return false } // 出生日期验证 var sBirthday=(sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2))).replace(/-/g,&quot;/&quot;), d = new Date(sBirthday) if(sBirthday != (d.getFullYear()+&quot;/&quot;+ (d.getMonth()+1) + &quot;/&quot; + d.getDate())) { alert(&apos;身份证上的出生日期非法&apos;) return false } // 身份证号码校验 var sum = 0, weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], codes = &quot;10X98765432&quot; for (var i = 0; i &lt; sId.length - 1; i++) { sum += sId[i] * weights[i]; } var last = codes[sum % 11]; //计算出来的最后一位身份证号码 if (sId[sId.length-1] != last) { alert(&apos;你输入的身份证号非法&apos;) return false } return true } } Date/** * 格式化时间 * * @param {time} 时间 * @param {cFormat} 格式 * @return {String} 字符串 * * @example formatTime(&apos;2018-1-29&apos;, &apos;{y}/{m}/{d} {h}:{i}:{s}&apos;) // -&gt; 2018/01/29 00:00:00 */ formatTime(time, cFormat) { if (arguments.length === 0) return null if ((time + &apos;&apos;).length === 10) { time = +time * 1000 } var format = cFormat || &apos;{y}-{m}-{d} {h}:{i}:{s}&apos;, date if (typeof time === &apos;object&apos;) { date = time } else { date = new Date(time) } var formatObj = { y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() } var time_str = format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) =&gt; { var value = formatObj[key] if (key === &apos;a&apos;) return [&apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;日&apos;][value - 1] if (result.length &gt; 0 &amp;&amp; value &lt; 10) { value = &apos;0&apos; + value } return value || 0 }) return time_str } /** * 返回指定长度的月份集合 * * @param {time} 时间 * @param {len} 长度 * @param {direction} 方向： 1: 前几个月; 2: 后几个月; 3:前后几个月 默认 3 * @return {Array} 数组 * * @example getMonths(&apos;2018-1-29&apos;, 6, 1) // -&gt; [&quot;2018-1&quot;, &quot;2017-12&quot;, &quot;2017-11&quot;, &quot;2017-10&quot;, &quot;2017-9&quot;, &quot;2017-8&quot;, &quot;2017-7&quot;] */ getMonths(time, len, direction) { var mm = new Date(time).getMonth(), yy = new Date(time).getFullYear(), direction = isNaN(direction) ? 3 : direction, index = mm; var cutMonth = function(index) { if ( index &lt;= len &amp;&amp; index &gt;= -len) { return direction === 1 ? formatPre(index).concat(cutMonth(++index)): direction === 2 ? formatNext(index).concat(cutMonth(++index)):formatCurr(index).concat(cutMonth(++index)) } return [] } var formatNext = function(i) { var y = Math.floor(i/12), m = i%12 return [yy+y + &apos;-&apos; + (m+1)] } var formatPre = function(i) { var y = Math.ceil(i/12), m = i%12 m = m===0 ? 12 : m return [yy-y + &apos;-&apos; + (13 - m)] } var formatCurr = function(i) { var y = Math.floor(i/12), yNext = Math.ceil(i/12), m = i%12, mNext = m===0 ? 12 : m return [yy-yNext + &apos;-&apos; + (13 - mNext),yy+y + &apos;-&apos; + (m+1)] } // 数组去重 var unique = function(arr) { if ( Array.hasOwnProperty(&apos;from&apos;) ) { return Array.from(new Set(arr)); }else{ var n = {},r=[]; for(var i = 0; i &lt; arr.length; i++){ if (!n[arr[i]]){ n[arr[i]] = true; r.push(arr[i]); } } return r; } } return direction !== 3 ? cutMonth(index) : unique(cutMonth(index).sort(function(t1, t2){ return new Date(t1).getTime() - new Date(t2).getTime() })) } /** * 返回指定长度的天数集合 * * @param {time} 时间 * @param {len} 长度 * @param {direction} 方向： 1: 前几天; 2: 后几天; 3:前后几天 默认 3 * @return {Array} 数组 * * @example date.getDays(&apos;2018-1-29&apos;, 6) // -&gt; [&quot;2018-1-26&quot;, &quot;2018-1-27&quot;, &quot;2018-1-28&quot;, &quot;2018-1-29&quot;, &quot;2018-1-30&quot;, &quot;2018-1-31&quot;, &quot;2018-2-1&quot;] */ getDays(time, len, diretion) { var tt = new Date(time) var getDay = function(day) { var t = new Date(time) t.setDate(t.getDate() + day) var m = t.getMonth()+1 return t.getFullYear()+&apos;-&apos;+m+&apos;-&apos;+t.getDate() } var arr = [] if (diretion === 1) { for (var i = 1; i &lt;= len; i++) { arr.unshift(getDay(-i)) } }else if(diretion === 2) { for (var i = 1; i &lt;= len; i++) { arr.push(getDay(i)) } }else { for (var i = 1; i &lt;= len; i++) { arr.unshift(getDay(-i)) } arr.push(tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()) for (var i = 1; i &lt;= len; i++) { arr.push(getDay(i)) } } return diretion === 1 ? arr.concat([tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()]) : diretion === 2 ? [tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()].concat(arr) : arr } /** * @param {s} 秒数 * @return {String} 字符串 * * @example formatHMS(3610) // -&gt; 1h0m10s */ formatHMS (s) { var str = &apos;&apos; if (s &gt; 3600) { str = Math.floor(s/3600)+&apos;h&apos;+Math.floor(s%3600/60)+&apos;m&apos;+s%60+&apos;s&apos; }else if(s &gt; 60) { str = Math.floor(s/60)+&apos;m&apos;+s%60+&apos;s&apos; }else{ str = s%60+&apos;s&apos; } return str } /*获取某月有多少天*/ getMonthOfDay (time) { var date = new Date(time) var year = date.getFullYear() var mouth = date.getMonth() + 1 var days //当月份为二月时，根据闰年还是非闰年判断天数 if (mouth == 2) { days = (year%4==0 &amp;&amp; year%100==0 &amp;&amp; year%400==0) || (year%4==0 &amp;&amp; year%100!=0) ? 28 : 29 } else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) { //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31； days = 31 } else { //其他月份，天数为：30. days = 30 } return days } /*获取某年有多少天*/ getYearOfDay (time) { var firstDayYear = this.getFirstDayOfYear(time); var lastDayYear = this.getLastDayOfYear(time); var numSecond = (new Date(lastDayYear).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600)); } /*获取某年的第一天*/ getFirstDayOfYear (time) { var year = new Date(time).getFullYear(); return year + &quot;-01-01 00:00:00&quot;; } /*获取某年最后一天*/ getLastDayOfYear (time) { var year = new Date(time).getFullYear(); var dateString = year + &quot;-12-01 00:00:00&quot;; var endDay = this.getMonthOfDay(dateString); return year + &quot;-12-&quot; + endDay + &quot; 23:59:59&quot;; } /*获取某个日期是当年中的第几天*/ getDayOfYear (time) { var firstDayYear = this.getFirstDayOfYear(time); var numSecond = (new Date(time).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600)); } /*获取某个日期在这一年的第几周*/ getDayOfYearWeek (time) { var numdays = this.getDayOfYear(time); return Math.ceil(numdays / 7); } Array/*判断一个元素是否在数组中*/ contains (arr, val) { return arr.indexOf(val) != -1 ? true : false; } /** * @param {arr} 数组 * @param {fn} 回调函数 * @return {undefined} */ each (arr, fn) { fn = fn || Function; var a = []; var args = Array.prototype.slice.call(arguments, 1); for(var i = 0; i &lt; arr.length; i++) { var res = fn.apply(arr, [arr[i], i].concat(args)); if(res != null) a.push(res); } } /** * @param {arr} 数组 * @param {fn} 回调函数 * @param {thisObj} this指向 * @return {Array} */ map (arr, fn, thisObj) { var scope = thisObj || window; var a = []; for(var i = 0, j = arr.length; i &lt; j; ++i) { var res = fn.call(scope, arr[i], i, this); if(res != null) a.push(res); } return a; } /** * @param {arr} 数组 * @param {type} 1：从小到大 2：从大到小 3：随机 * @return {Array} */ sort (arr, type = 1) { return arr.sort( (a, b) =&gt; { switch(type) { case 1: return a - b; case 2: return b - a; case 3: return Math.random() - 0.5; default: return arr; } }) } /*去重*/ unique (arr) { if ( Array.hasOwnProperty(&apos;from&apos;) ) { return Array.from(new Set(arr)); }else{ var n = {},r=[]; for(var i = 0; i &lt; arr.length; i++){ if (!n[arr[i]]){ n[arr[i]] = true; r.push(arr[i]); } } return r; } // 注：上面 else 里面的排重并不能区分 2 和 &apos;2&apos;，但能减少用indexOf带来的性能,暂时没找到替代的方法。。。 /* 正确排重 if ( Array.hasOwnProperty(&apos;from&apos;) ) { return Array.from(new Set(arr)) }else{ var r = [], NaNBol = true for(var i=0; i &lt; arr.length; i++) { if (arr[i] !== arr[i]) { if (NaNBol &amp;&amp; r.indexOf(arr[i]) === -1) { r.push(arr[i]) NaNBol = false } }else{ if(r.indexOf(arr[i]) === -1) r.push(arr[i]) } } return r } */ } /*求两个集合的并集*/ union (a, b) { var newArr = a.concat(b); return this.unique(newArr); } /*求两个集合的交集*/ intersect (a, b) { var _this = this; a = this.unique(a); return this.map(a, function(o) { return _this.contains(b, o) ? o : null; }); } /*删除其中一个元素*/ remove (arr, ele) { var index = arr.indexOf(ele); if(index &gt; -1) { arr.splice(index, 1); } return arr; } /*将类数组转换为数组的方法*/ formArray (ary) { var arr = []; if(Array.isArray(ary)) { arr = ary; } else { arr = Array.prototype.slice.call(ary); }; return arr; } /*最大值*/ max (arr) { return Math.max.apply(null, arr); } /*最小值*/ min (arr) { return Math.min.apply(null, arr); } /*求和*/ sum (arr) { return arr.reduce( (pre, cur) =&gt; { return pre + cur }) } /*平均值*/ average (arr) { return this.sum(arr)/arr.length } String 字符串操作/** * 去除空格 * @param {str} * @param {type} * type: 1-所有空格 2-前后空格 3-前空格 4-后空格 * @return {String} */ trim (str, type) { type = type || 1 switch (type) { case 1: return str.replace(/\s+/g, &quot;&quot;); case 2: return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); case 3: return str.replace(/(^\s*)/g, &quot;&quot;); case 4: return str.replace(/(\s*$)/g, &quot;&quot;); default: return str; } } /** * @param {str} * @param {type} * type: 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 * @return {String} */ changeCase (str, type) { type = type || 4 switch (type) { case 1: return str.replace(/\b\w+\b/g, function (word) { return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); }); case 2: return str.replace(/\b\w+\b/g, function (word) { return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); }); case 3: return str.split(&apos;&apos;).map( function(word){ if (/[a-z]/.test(word)) { return word.toUpperCase(); }else{ return word.toLowerCase() } }).join(&apos;&apos;) case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; } } / 检测密码强度 / checkPwd (str) { var Lv = 0; if (str.length &lt; 6) { return Lv } if (/[0-9]/.test(str)) { Lv++ } if (/[a-z]/.test(str)) { Lv++ } if (/[A-Z]/.test(str)) { Lv++ } if (/[\.|-|_]/.test(str)) { Lv++ } return Lv; } /*过滤html代码(把&lt;&gt;转换)*/ filterTag (str) { str = str.replace(/&amp;/ig, &quot;&amp;amp;&quot;); str = str.replace(/&lt;/ig, &quot;&amp;lt;&quot;); str = str.replace(/&gt;/ig, &quot;&amp;gt;&quot;); str = str.replace(&quot; &quot;, &quot;&amp;nbsp;&quot;); return str; } Number/随机数范围/random (min, max) { if (arguments.length === 2) { return Math.floor(min + Math.random() * ( (max+1) - min )) }else{ return null; } } /将阿拉伯数字翻译成中文的大写数字/numberToChinese (num) { var AA = new Array(“零”, “一”, “二”, “三”, “四”, “五”, “六”, “七”, “八”, “九”, “十”); var BB = new Array(“”, “十”, “百”, “仟”, “萬”, “億”, “点”, “”); var a = (“” + num).replace(/(^0*)/g, “”).split(“.”), k = 0, re = “”; for(var i = a[0].length - 1; i &gt;= 0; i–) { switch(k) { case 0: re = BB[7] + re; break; case 4: if(!new RegExp(“0{4}//d{“ + (a[0].length - i - 1) + “}$”) .test(a[0])) re = BB[4] + re; break; case 8: re = BB[5] + re; BB[7] = BB[5]; k = 0; break; } if(k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0) re = AA[0] + re; if(a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re; k++; } if(a.length &gt; 1) // 加上小数部分(如果有小数部分) { re += BB[6]; for(var i = 0; i &lt; a[1].length; i++) re += AA[a[1].charAt(i)]; } if(re == &apos;一十&apos;) re = &quot;十&quot;; if(re.match(/^一/) &amp;&amp; re.length == 3) re = re.replace(&quot;一&quot;, &quot;&quot;); return re; } /将数字转换为大写金额/changeToChinese (Num) { //判断如果传递进来的不是字符的话转换为字符 if(typeof Num == “number”) { Num = new String(Num); }; Num = Num.replace(/,/g, “”) //替换tomoney()中的“,” Num = Num.replace(/ /g, “”) //替换tomoney()中的空格 Num = Num.replace(/￥/g, “”) //替换掉可能出现的￥字符 if(isNaN(Num)) { //验证输入的字符是否为数字 //alert(“请检查小写金额是否正确”); return “”; }; //字符处理完毕后开始转换，采用前后两部分分别转换 var part = String(Num).split(“.”); var newchar = “”; //小数点前进行转化 for(var i = part[0].length - 1; i &gt;= 0; i–) { if(part[0].length &gt; 10) { return “”; //若数量超过拾亿单位，提示 } var tmpnewchar = “” var perchar = part[0].charAt(i); switch(perchar) { case “0”: tmpnewchar = “零” + tmpnewchar; break; case “1”: tmpnewchar = “壹” + tmpnewchar; break; case “2”: tmpnewchar = “贰” + tmpnewchar; break; case “3”: tmpnewchar = “叁” + tmpnewchar; break; case “4”: tmpnewchar = “肆” + tmpnewchar; break; case “5”: tmpnewchar = “伍” + tmpnewchar; break; case “6”: tmpnewchar = “陆” + tmpnewchar; break; case “7”: tmpnewchar = “柒” + tmpnewchar; break; case “8”: tmpnewchar = “捌” + tmpnewchar; break; case “9”: tmpnewchar = “玖” + tmpnewchar; break; } switch(part[0].length - i - 1) { case 0: tmpnewchar = tmpnewchar + “元”; break; case 1: if(perchar != 0) tmpnewchar = tmpnewchar + “拾”; break; case 2: if(perchar != 0) tmpnewchar = tmpnewchar + “佰”; break; case 3: if(perchar != 0) tmpnewchar = tmpnewchar + “仟”; break; case 4: tmpnewchar = tmpnewchar + “万”; break; case 5: if(perchar != 0) tmpnewchar = tmpnewchar + “拾”; break; case 6: if(perchar != 0) tmpnewchar = tmpnewchar + “佰”; break; case 7: if(perchar != 0) tmpnewchar = tmpnewchar + “仟”; break; case 8: tmpnewchar = tmpnewchar + “亿”; break; case 9: tmpnewchar = tmpnewchar + “拾”; break; } var newchar = tmpnewchar + newchar; } //小数点之后进行转化 if(Num.indexOf(“.”) != -1) { if(part[1].length &gt; 2) { // alert(“小数点之后只能保留两位,系统将自动截断”); part[1] = part[1].substr(0, 2) } for(i = 0; i &lt; part[1].length; i++) { tmpnewchar = “” perchar = part[1].charAt(i) switch(perchar) { case “0”: tmpnewchar = “零” + tmpnewchar; break; case “1”: tmpnewchar = “壹” + tmpnewchar; break; case “2”: tmpnewchar = “贰” + tmpnewchar; break; case “3”: tmpnewchar = “叁” + tmpnewchar; break; case “4”: tmpnewchar = “肆” + tmpnewchar; break; case “5”: tmpnewchar = “伍” + tmpnewchar; break; case “6”: tmpnewchar = “陆” + tmpnewchar; break; case “7”: tmpnewchar = “柒” + tmpnewchar; break; case “8”: tmpnewchar = “捌” + tmpnewchar; break; case “9”: tmpnewchar = “玖” + tmpnewchar; break; } if(i == 0) tmpnewchar = tmpnewchar + “角”; if(i == 1) tmpnewchar = tmpnewchar + “分”; newchar = newchar + tmpnewchar; } } //替换所有无用汉字 while(newchar.search(“零零”) != -1) newchar = newchar.replace(“零零”, “零”); newchar = newchar.replace(“零亿”, “亿”); newchar = newchar.replace(“亿万”, “亿”); newchar = newchar.replace(“零万”, “万”); newchar = newchar.replace(“零元”, “元”); newchar = newchar.replace(“零角”, “”); newchar = newchar.replace(“零分”, “”); if(newchar.charAt(newchar.length - 1) == “元”) { newchar = newchar + “整” } return newchar; } Http/** * @param {setting} */ ajax(setting){ //设置参数的初始值 var opts={ method: (setting.method || &quot;GET&quot;).toUpperCase(), //请求方式 url: setting.url || &quot;&quot;, // 请求地址 async: setting.async || true, // 是否异步 dataType: setting.dataType || &quot;json&quot;, // 解析方式 data: setting.data || &quot;&quot;, // 参数 success: setting.success || function(){}, // 请求成功回调 error: setting.error || function(){} // 请求失败回调 } // 参数格式化 function params_format (obj) { var str = &apos;&apos; for (var i in obj) { str += i + &apos;=&apos; + obj[i] + &apos;&amp;&apos; } return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;) } // 创建ajax对象 var xhr=new XMLHttpRequest(); // 连接服务器open(方法GET/POST，请求地址， 异步传输) if(opts.method == &apos;GET&apos;){ xhr.open(opts.method, opts.url + &quot;?&quot; + params_format(opts.data), opts.async); xhr.send(); }else{ xhr.open(opts.method, opts.url, opts.async); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(opts.data); } / 每当readyState改变时，就会触发onreadystatechange事件 readyState属性存储有XMLHttpRequest的状态信息 0 ：请求未初始化 1 ：服务器连接已建立 2 ：请求已接受 3 : 请求处理中 ** 4 ：请求已完成，且相应就绪 / xhr.onreadystatechange = function() { if (xhr.readyState === 4 &amp;&amp; (xhr.status === 200 || xhr.status === 304)) { switch(opts.dataType){ case &quot;json&quot;: var json = JSON.parse(xhr.responseText); opts.success(json); break; case &quot;xml&quot;: opts.success(xhr.responseXML); break; default: opts.success(xhr.responseText); break; } } } xhr.onerror = function(err) { opts.error(err); } } /** * @param {url} * @param {setting} * @return {Promise} */ fetch(url, setting) { //设置参数的初始值 let opts={ method: (setting.method || &apos;GET&apos;).toUpperCase(), //请求方式 headers : setting.headers || {}, // 请求头设置 credentials : setting.credentials || true, // 设置cookie是否一起发送 body: setting.body || {}, mode : setting.mode || &apos;no-cors&apos;, // 可以设置 cors, no-cors, same-origin redirect : setting.redirect || &apos;follow&apos;, // follow, error, manual cache : setting.cache || &apos;default&apos; // 设置 cache 模式 (default, reload, no-cache) } let dataType = setting.dataType || &quot;json&quot;, // 解析方式 data = setting.data || &quot;&quot; // 参数 // 参数格式化 function params_format (obj) { var str = &apos;&apos; for (var i in obj) { str += `${i}=${obj[i]}&amp;` } return str.split(&apos;&apos;).slice(0, -1).join(&apos;&apos;) } if (opts.method === &apos;GET&apos;) { url = url + (data?`?${params_format(data)}`:&apos;&apos;) }else{ setting.body = data || {} } return new Promise( (resolve, reject) =&gt; { fetch(url, opts).then( async res =&gt; { let data = dataType === &apos;text&apos; ? await res.text() : dataType === &apos;blob&apos; ? await res.blob() : await res.json() resolve(data) }).catch( e =&gt; { reject(e) }) }) } DOM$ (selector){ var type = selector.substring(0, 1); if (type === &apos;#&apos;) { if (document.querySelecotor) return document.querySelector(selector) return document.getElementById(selector.substring(1)) }else if (type === &apos;.&apos;) { if (document.querySelecotorAll) return document.querySelectorAll(selector) return document.getElementsByClassName(selector.substring(1)) }else{ return document[&apos;querySelectorAll&apos; ? &apos;querySelectorAll&apos;:&apos;getElementsByTagName&apos;](selector) } } /*检测类名*/ hasClass (ele, name) { return ele.className.match(new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;)); } /*添加类名*/ addClass (ele, name) { if (!this.hasClass(ele, name)) ele.className += &quot; &quot; + name; } /*删除类名*/ removeClass (ele, name) { if (this.hasClass(ele, name)) { var reg = new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;); ele.className = ele.className.replace(reg, &apos;&apos;); } } /*替换类名*/ replaceClass (ele, newName, oldName) { this.removeClass(ele, oldName); this.addClass(ele, newName); } /*获取兄弟节点*/ siblings (ele) { console.log(ele.parentNode) var chid = ele.parentNode.children,eleMatch = []; for(var i = 0, len = chid.length; i &lt; len; i ++){ if(chid[i] != ele){ eleMatch.push(chid[i]); } } return eleMatch; } /*获取行间样式属性*/ getByStyle (obj,name){ if(obj.currentStyle){ return obj.currentStyle[name]; }else{ return getComputedStyle(obj,false)[name]; } } Storage 储存操作class StorageFn { constructor () { this.ls = window.localStorage; this.ss = window.sessionStorage; } /*-----------------cookie---------------------*/ /*设置cookie*/ setCookie (name, value, day) { var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){ for (var i in setting) { var oDate = new Date(); oDate.setDate(oDate.getDate() + day); document.cookie = i + &apos;=&apos; + setting[i] + &apos;;expires=&apos; + oDate; } }else{ var oDate = new Date(); oDate.setDate(oDate.getDate() + day); document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + oDate; } } /*获取cookie*/ getCookie (name) { var arr = document.cookie.split(&apos;; &apos;); for (var i = 0; i &lt; arr.length; i++) { var arr2 = arr[i].split(&apos;=&apos;); if (arr2[0] == name) { return arr2[1]; } } return &apos;&apos;; } /*删除cookie*/ removeCookie (name) { this.setCookie(name, 1, -1); } /*-----------------localStorage---------------------*/ /*设置localStorage*/ setLocal(key, val) { var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){ for(var i in setting){ this.ls.setItem(i, JSON.stringify(setting[i])) } }else{ this.ls.setItem(key, JSON.stringify(val)) } } /*获取localStorage*/ getLocal(key) { if (key) return JSON.parse(this.ls.getItem(key)) return null; } /*移除localStorage*/ removeLocal(key) { this.ls.removeItem(key) } /*移除所有localStorage*/ clearLocal() { this.ls.clear() } /*-----------------sessionStorage---------------------*/ /*设置sessionStorage*/ setSession(key, val) { var setting = arguments[0]; if (Object.prototype.toString.call(setting).slice(8, -1) === &apos;Object&apos;){ for(var i in setting){ this.ss.setItem(i, JSON.stringify(setting[i])) } }else{ this.ss.setItem(key, JSON.stringify(val)) } } /*获取sessionStorage*/ getSession(key) { if (key) return JSON.parse(this.ss.getItem(key)) return null; } /*移除sessionStorage*/ removeSession(key) { this.ss.removeItem(key) } /*移除所有sessionStorage*/ clearSession() { this.ss.clear() } } Other 其它操作/*获取网址参数*/ getURL(name){ var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); var r = decodeURI(window.location.search).substr(1).match(reg); if(r!=null) return r[2]; return null; } /*获取全部url参数,并转换成json对象*/ getUrlAllParams (url) { var url = url ? url : window.location.href; var _pa = url.substring(url.indexOf(&apos;?&apos;) + 1), _arrS = _pa.split(&apos;&amp;&apos;), _rs = {}; for (var i = 0, _len = _arrS.length; i &lt; _len; i++) { var pos = _arrS[i].indexOf(&apos;=&apos;); if (pos == -1) { continue; } var name = _arrS[i].substring(0, pos), value = window.decodeURIComponent(_arrS[i].substring(pos + 1)); _rs[name] = value; } return _rs; } /*删除url指定参数，返回url*/ delParamsUrl(url, name){ var baseUrl = url.split(&apos;?&apos;)[0] + &apos;?&apos;; var query = url.split(&apos;?&apos;)[1]; if (query.indexOf(name)&gt;-1) { var obj = {} var arr = query.split(&quot;&amp;&quot;); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(&quot;=&quot;); obj[arr[i][0]] = arr[i][1]; }; delete obj[name]; var url = baseUrl + JSON.stringify(obj).replace(/[\&quot;\{\}]/g,&quot;&quot;).replace(/\:/g,&quot;=&quot;).replace(/\,/g,&quot;&amp;&quot;); return url }else{ return url; } } /*获取十六进制随机颜色*/ getRandomColor () { return &apos;#&apos; + (function(h) { return new Array(7 - h.length).join(&quot;0&quot;) + h; })((Math.random() * 0x1000000 &lt;&lt; 0).toString(16)); } /*图片加载*/ imgLoadAll(arr,callback){ var arrImg = []; for (var i = 0; i &lt; arr.length; i++) { var img = new Image(); img.src = arr[i]; img.onload = function(){ arrImg.push(this); if (arrImg.length == arr.length) { callback &amp;&amp; callback(); } } } } /*音频加载*/ loadAudio(src, callback) { var audio = new Audio(src); audio.onloadedmetadata = callback; audio.src = src; } /*DOM转字符串*/ domToStirng(htmlDOM){ var div= document.createElement(&quot;div&quot;); div.appendChild(htmlDOM); return div.innerHTML } /*字符串转DOM*/ stringToDom(htmlString){ var div= document.createElement(&quot;div&quot;); div.innerHTML=htmlString; return div.children[0]; } /** * 光标所在位置插入字符，并设置光标位置 * * @param {dom} 输入框 * @param {val} 插入的值 * @param {posLen} 光标位置处在 插入的值的哪个位置 */ setCursorPosition (dom,val,posLen) { var cursorPosition = 0; if(dom.selectionStart){ cursorPosition = dom.selectionStart; } this.insertAtCursor(dom,val); dom.focus(); console.log(posLen) dom.setSelectionRange(dom.value.length,cursorPosition + (posLen || val.length)); } /*光标所在位置插入字符*/ insertAtCursor(dom, val) { if (document.selection){ dom.focus(); sel = document.selection.createRange(); sel.text = val; sel.select(); }else if (dom.selectionStart || dom.selectionStart == &apos;0&apos;){ let startPos = dom.selectionStart; let endPos = dom.selectionEnd; let restoreTop = dom.scrollTop; dom.value = dom.value.substring(0, startPos) + val + dom.value.substring(endPos, dom.value.length); if (restoreTop &gt; 0){ dom.scrollTop = restoreTop; } dom.focus(); dom.selectionStart = startPos + val.length; dom.selectionEnd = startPos + val.length; } else { dom.value += val; dom.focus(); } } CSS pc-reset PC样式初始化/* normalize.css */ html { line-height: 1.15; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } article, aside, footer, header, nav, section { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } figcaption, figure, main { /* 1 */ display: block; } figure { margin: 1em 40px; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */ } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: inherit; } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } dfn { font-style: italic; } mark { background-color: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } audio, video { display: inline-block; } audio:not([controls]) { display: none; height: 0; } img { border-style: none; } svg:not(:root) { overflow: hidden; } button, input, optgroup, select, textarea { font-family: sans-serif; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, html [type=&quot;button&quot;], /* 1 */ [type=&quot;reset&quot;], [type=&quot;submit&quot;] { -webkit-appearance: button; /* 2 */ } button::-moz-focus-inner, [type=&quot;button&quot;]::-moz-focus-inner, [type=&quot;reset&quot;]::-moz-focus-inner, [type=&quot;submit&quot;]::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type=&quot;button&quot;]:-moz-focusring, [type=&quot;reset&quot;]:-moz-focusring, [type=&quot;submit&quot;]:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { display: inline-block; /* 1 */ vertical-align: baseline; /* 2 */ } textarea { overflow: auto; } [type=&quot;checkbox&quot;], [type=&quot;radio&quot;] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type=&quot;number&quot;]::-webkit-inner-spin-button, [type=&quot;number&quot;]::-webkit-outer-spin-button { height: auto; } [type=&quot;search&quot;] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type=&quot;search&quot;]::-webkit-search-cancel-button, [type=&quot;search&quot;]::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details, /* 1 */ menu { display: block; } summary { display: list-item; } canvas { display: inline-block; } template { display: none; } [hidden] { display: none; } /* reset */ html, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu { margin: 0; padding: 0; box-sizing: border-box; } Phone-reset/* normalize.css */ html { line-height: 1.15; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } article, aside, footer, header, nav, section { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } figcaption, figure, main { /* 1 */ display: block; } figure { margin: 1em 40px; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */ } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: inherit; } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } dfn { font-style: italic; } mark { background-color: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } audio, video { display: inline-block; } audio:not([controls]) { display: none; height: 0; } img { border-style: none; } svg:not(:root) { overflow: hidden; } button, input, optgroup, select, textarea { font-family: sans-serif; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, html [type=&quot;button&quot;], /* 1 */ [type=&quot;reset&quot;], [type=&quot;submit&quot;] { -webkit-appearance: button; /* 2 */ } button::-moz-focus-inner, [type=&quot;button&quot;]::-moz-focus-inner, [type=&quot;reset&quot;]::-moz-focus-inner, [type=&quot;submit&quot;]::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type=&quot;button&quot;]:-moz-focusring, [type=&quot;reset&quot;]:-moz-focusring, [type=&quot;submit&quot;]:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { display: inline-block; /* 1 */ vertical-align: baseline; /* 2 */ } textarea { overflow: auto; } [type=&quot;checkbox&quot;], [type=&quot;radio&quot;] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type=&quot;number&quot;]::-webkit-inner-spin-button, [type=&quot;number&quot;]::-webkit-outer-spin-button { height: auto; } [type=&quot;search&quot;] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type=&quot;search&quot;]::-webkit-search-cancel-button, [type=&quot;search&quot;]::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details, /* 1 */ menu { display: block; } summary { display: list-item; } canvas { display: inline-block; } template { display: none; } [hidden] { display: none; } /* reset */ html, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu { margin: 0; padding: 0; box-sizing: border-box; } html, body { /* 禁止选中文本 */ -webkit-user-select: none; user-select: none; font: Oswald, &apos;Open Sans&apos;, Helvetica, Arial, sans-serif } /* 禁止长按链接与图片弹出菜单 */ a, img { -webkit-touch-callout: none; } /*ios android去除自带阴影的样式*/ a, input { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } input[type=&quot;text&quot;] { -webkit-appearance: none; } 公共样式提取/* 禁止选中文本 */ .usn{ -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; -o-user-select:none; user-select:none; } /* 浮动 */ .fl { float: left; } .fr { float: right; } .cf { zoom: 1; } .cf:after { content:&quot;.&quot;; display:block; clear:both; visibility:hidden; height:0; overflow:hidden; } /* 元素类型 */ .db { display: block; } .dn { display: none; } .di { display: inline } .dib {display: inline-block;} .transparent { opacity: 0 } /*文字排版、颜色*/ .f12 { font-size:12px } .f14 { font-size:14px } .f16 { font-size:16px } .f18 { font-size:18px } .f20 { font-size:20px } .fb { font-weight:bold } .fn { font-weight:normal } .t2 { text-indent:2em } .red,a.red { color:#cc0031 } .darkblue,a.darkblue { color:#039 } .gray,a.gray { color:#878787 } .lh150 { line-height:150% } .lh180 { line-height:180% } .lh200 { line-height:200% } .unl { text-decoration:underline; } .no_unl { text-decoration:none; } .tl { text-align: left; } .tc { text-align: center; } .tr { text-align: right; } .tj { text-align: justify; text-justify: inter-ideograph; } .wn { /* 强制不换行 */ word-wrap:normal; white-space:nowrap; } .wb { /* 强制换行 */ white-space:normal; word-wrap:break-word; word-break:break-all; } .wp { /* 保持空白序列*/ overflow:hidden;text-align:left;white-space:pre-wrap;word-wrap:break-word;word-break:break-all; } .wes { /* 多出部分用省略号表示 , 用于一行 */ overflow:hidden; word-wrap:normal; white-space:nowrap; text-overflow:ellipsis; } .wes-2 { /* 适用于webkit内核和移动端 */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } .wes-3 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } .wes-4 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; } /* 溢出样式 */ .ofh { overflow: hidden; } .ofs {overflow: scroll; } .ofa {overflow: auto; } .ofv {overflow: visible; } /* 定位方式 */ .ps {position: static; } .pr {position: relative;zoom:1; } .pa {position: absolute; } .pf {position: fixed; } /* 垂直对齐方式 */ .vt {vertical-align: top; } .vm {vertical-align: middle; } .vb {vertical-align: bottom; } /* 鼠标样式 */ .csd {cursor: default; } .csp {cursor: pointer; } .csh {cursor: help; } .csm {cursor: move; } /* flex布局 */ .df-sb { display:flex; align-items: center; justify-content: space-between; } .df-sa { display:flex; align-items: center; justify-content: space-around; } /* 垂直居中 */ .df-c { display: flex; align-items: center; justify-content: center; } .tb-c { text-align:center; display:table-cell; vertical-align:middle; } .ts-c { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } .ts-mc { position: absolute; left: 0;right: 0; bottom: 0; top: 0; margin: auto; } /* 辅助 */ .mask-fixed-wrapper { width: 100%; height: 100%; position: fixed; left:0;top:0; background: rgba(0, 0, 0, 0.65); z-index: 999; } .bg-cover { background-size: cover; background-repeat: no-repeat; background-position: center center; } .bg-cover-all { background-size: 100% 100%; background-repeat: no-repeat; background-position: center center; }]]></content>
      <tags>
        <tag>前端js学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt.js学习]]></title>
    <url>%2Fframe%2Fnuxt.html</url>
    <content type="text"><![CDATA[关于Nuxt.js2016年10月25日，zeit.co背后的团队对外发布了Next.js，一个react的服务端渲染应用框架。几个小时后，与Next.js异曲同工，一个基于vue.js的服务端渲染应用框架应用而生，我们称之：Nuxt.js。 Nuxt.js是什么？Nuxt.js是一个基于vue.js的通用应用框架 通过对客户端/服务端基础架构的抽象组织，Nuxt.js只要关注的是应用的UI渲染 我们的目标是插件一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有的Node.js项目中使用Nuxt.js Nuxt.js预设了利用vue.js开发服务端渲染的应用所需要的各种配置 除此之外，我们还提供了一种命令叫：nuxt generate，为基于vue.js的用用提供生成对应的静态站点的功能 我们相信这个命令所提供的功能，是向开发集成各种微服务的web应用迈开的新一步 作为框架，nuxt.js为客户端/服务端这种典型的应用框架模式提供了许多有用的特性，例如异步数据加载，中间件支持，布局支持等]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js第一个应用]]></title>
    <url>%2Fnode%2Fnode.js%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[什么是node.js？ 简单的说node.js就是运行在服务端的JavaScript node.js是一个基于chrome javascript 运行时建立的一个平台 node.js是一个事件驱动I/O服务器JavaScript环境，基于Google的v8殷勤，v8殷勤执行JavaScript的速度非常快，性能非常好 查看版本 node -v 注意：不同版本间是有差异性的 第一个node.js程序： hello world! 脚本模式 console.log(“hello world!”); 保存该文件，文件名为helloworld.js，并通过node命令来执行 node helloworld.js 程序执行结果为 hello world! 交互模式 打开终端，输入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果 nodeconsole.log(‘hello world!’) hello world! 创建node的第一个应用 如果我们使用PHP来编写后端的代码时，需要Apache或者Nginx的http服务器，并配置mod_php5模块和php_cgi 从这个角度看，整个接受http请求并提供web页面的需求根本不需要PHP来处理 不过对node.js来说，概念就完全不一样了，使用node.js时，我们不仅仅在实现一个应用，同事还实现了整个http服务器 事实上，我们的web应用以及对应的web服务器基本上是一致的 在我们创建node的第一个程序“hello world!”应用前，让我们先了解下node.js应用由那几个部分组成 1.引入required模块：我们可以使用require指令来载入node.js模块 2.穿件服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等http服务器 3.接受请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接受请求后返回响应数据 创建node.js应用 步骤一：引入required模块 我们使用require指令来载入http模块，并将实例化的http赋值给变量http var http = require(‘http’) 步骤二：创建服务器 接下来我们使用http.createServer()方法创建服务器，并使用listen方法绑定8888端口。函数通过request、response参数来接收数据和响应数据实例如下，在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码 var http = require(&apos;http); http.createServer(function (request, response) { // 发送http头部 // http状态值：200 : ok // 内容类型：text/plain response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos; }) // 发送响应数据“hello world” }).listen(8888) // 终端打印如下结果 console.log(&apos;Server running at http://127.0.0.1:8888/&apos;) 以上代码我们完成了一个可以工作的http服务器使用node命令执行以上代码 node server.js 结果：Server running at http://127.0.0.1:8888/ 分析： 第一行请求（require）node.js自带的http模块，并把它赋值给http变量 接下来我们调用http模块提供的函数：createServer，这个函数会返回一个对象，对象有个叫listen的方法，这个方法有个数值参数，指定这个http服务器监听的端口号]]></content>
      <tags>
        <tag>node.js学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环]]></title>
    <url>%2Fjavascript%2Fjs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html</url>
    <content type="text"><![CDATA[一、为什么JS是单线程是由JS的用途决定的，其用途主要是与用户互动，以及操作DOM，如果不是单线程的话会带来很复杂的同步问题。比如：如果是多线程的话，一个用户新建一个DOM，另一个用户删除同一个DOM，该如何处理将变得非常麻烦。 在html5中提出了web worker（todo 改天添加web worker的讲解）标准，JS可以创建多个线程或者是iframe，但是其他子线程主要是用来进行JS计算不能操作DOM，且受到子线程的控制。所以也并没有改变JS单线程的本质 二、同步和异步由于是单线程，所有任务需要排队，但是如果队列中所有的任务都是同步的话会造成资源的浪费。 于是任务分为两类：同步任务和异步任务。 异步任务的过程： 主线程（函数调用栈）发起一个异步请求，相应的工作线程接收请求，并告知主线程已经收到，主线程继续执行后面的同步代码，同时工作线程执行异步任务，工作线程完成工作后，通知主线程，主线程收到通知后，执行回调函数 三、宏任务和微任务宏任务（micro-task）主要是：script代码段、setTimeout、setInterval、Promise的构造函数是同步的、setImmediate、I/O、UIrendering 微任务（macro-task）主要是：Promise的回调、process.nextTick 四、任务队列和事件循环了解任务队列之前，先了解一下任务源，我们将发起异步任务的称之为任务源（setTimeout、Promise等），进入任务队列的是他们指定的任务。 在一个线程中，事件循环是唯一的，任务队列是多个的。来自不同任务源的队列进入到不同的任务队列，setTimeout和setInterval是同源的 事件循环的步骤：1、运行主线程（函数调用栈）中的同步任务 2、主线程（函数调用栈）执行到任务源时，通知相应的webAPIs进行相应的执行异步任务，将任务源指定的异步任务放入任务队列中 3、主线程（函数调用栈）中的任务执行完毕后，然后执行所有的微任务，再执行宏任务，找到一个任务队列执行完毕，再执行所有的微任务 4、不断执行第三步 事件循环：指主线程重复从任务队列中取消息，执行的过程 先来一个简单的例子： setTimeout(() =&gt; { console.log(&apos;begin&apos;) }) new Promise((resolve) =&gt; { console.log(&apos;promise begin&apos;) for(let i = 0; i &lt; 1000; i++) { i == 999 &amp;&amp; resolve() } }).then(() =&gt; { console.log(&apos;then begin&apos;) }) console.log(&apos;end&apos;) 因为promise的构造函数是同步的，promise.then是异步的微任务，所以promise beigin先于end根据上面对宏任务和微任务的分析，其输出的情况为【promise begin——end——then begin——begin】再来一个复杂点的，我们来一步一步的分析一个例子来看： console.log(&apos;golb1&apos;); setTimeout(function() { console.log(&apos;timeout1&apos;); process.nextTick(function() { console.log(&apos;timeout1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;timeout1_promise&apos;); resolve(); }).then(function() { console.log(&apos;timeout1_then&apos;) }) }) setImmediate(function() { console.log(&apos;immediate1&apos;); process.nextTick(function() { console.log(&apos;immediate1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;immediate1_promise&apos;); resolve(); }).then(function() { console.log(&apos;immediate1_then&apos;) }) }) process.nextTick(function() { console.log(&apos;glob1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;glob1_promise&apos;); resolve(); }).then(function() { console.log(&apos;glob1_then&apos;) }) setTimeout(function() { console.log(&apos;timeout2&apos;); process.nextTick(function() { console.log(&apos;timeout2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;timeout2_promise&apos;); resolve(); }).then(function() { console.log(&apos;timeout2_then&apos;) }) }) process.nextTick(function() { console.log(&apos;glob2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;glob2_promise&apos;); resolve(); }).then(function() { console.log(&apos;glob2_then&apos;) }) setImmediate(function() { console.log(&apos;immediate2&apos;); process.nextTick(function() { console.log(&apos;immediate2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;immediate2_promise&apos;); resolve(); }).then(function() { console.log(&apos;immediate2_then&apos;) }) }) 一、第一步、首先执行宏任务script。全局入栈。输出glob1 二、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列 三、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列 四、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列 五、遇到Promise的构造函数，进入执行栈，输出glob1_promise，Promise.then()作为任务源，将指定的任务加入微任务 六、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列 七、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列 八、遇到Promise的构造函数，进入执行栈，输出glob2_promise，Promise.then()作为任务源，将指定的任务加入微任务 九、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列 十、执行所有微任务队列，输出glob1_nextTick和glob2_nextTick、glob1_then、glob2_then 事件机制其实就是异步任务的通知机制]]></content>
      <tags>
        <tag>前端js学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[段落第一自然段 第二自然段 注意：换行不是分段的标识，空行才是 标题一级标题二级标题三级标题四级标题五级标题六级标题注：# 和后续内容之间应放置一个空格 列表(1) 有序列表 打开冰箱门 把大象放进冰箱 关上冰箱门 (2) 无序列表 吃饭 睡觉 打豆豆 注意事项： 无序列表的项目符号可使用 *,+,- 效果是相同的。 列表与后续内容之间需要一个空行隔开，即：列表是一个段落 列表允许多层次嵌套 可以在项目中包含段落，只需将段落前添加一个 tab 或 4 个空格 分割线语法：使用 3 个连续的 * 即可得到一个分割线 引用语法：在行头加上 &gt; 即可。 这里是一段引用 大于号 和 文字必须有一个空格 可以在每行之前加 &gt; ，也可以在段落之前加 1 个 &gt; 引用内部可以使用其他 Markdown 标记 引用内部可以添加新的引用，只需再加一个大于号 行内标记(1) 强调文字 斜体 语法：使用前后各 1 个 *(或_) 包含的文字是 斜体 文字 *斜体*, _斜体_ 粗体 语法：使用前后各 2 个 *(或_) 包含的文字是 粗体 文字 **粗体**，__粗体__ 删除文字 语法：使用前后各 2 个 ~ 包含的文字是删除文字 ~~删除~~ 粗斜体 语法：在**(或__)中嵌套_ (或*) 或 在_(或*)中嵌套**(或__)即可得到 粗斜体。 _**粗斜体**_， *__粗斜体__* **_粗斜体_**， __*粗斜体*__ (2) 图片与链接 1.图片：行内图片、引用图片 1&gt; 行内图片 图片和图片地址写在一起。 语法： ![图片标题](图片url) ![史努比](http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 2&gt; 引用图片 图片和图片地址分开书写。 语法： ![图片标题][图片id] [图片id]:图片url ![史努比][snoopy] [snoopy]: http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 2. 链接：行内链接、链接引用、自动链接 1&gt; 行内链接 语法：[链接名称](链接地址 url &quot;链接title&quot;) 示例代码 [新浪](http://www.sina.com.cn &quot;新浪主页&quot;) 新浪 注意事项 双引号中的内容是链接的 title (目前汉字显示不正确) 2&gt; 链接引用 一种链接和地址分离的方式。 [链接名称][链接id] [链接id]:链接 url 地址 &quot;链接 title&quot; 示例代码 根据 [雅虎][yahoo] 的调查，希拉里将当选；根据 [谷歌][google] 的调查，川普将当选。 [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [google]: http://google.com/ &quot;Google&quot; 根据 雅虎 的调查，希拉里将当选；根据 谷歌 的调查，川普将当选。 注意事项 链接 id 可使用字母、数字、空格，但不区分大小写 3.脚注 -- 为名词提供注释，注释将显示在文章末尾。 语法： 待解释文字[^脚注 id] [^脚注 id]:注释内容 示例代码 Hello程序[^hello] [^hello]:即：Hello, world 程序 Hello程序[^hello][^hello]:即：Hello, world 程序 注意事项 脚注 id 必须唯一 无论脚注 id 如何起名，显示时一律标为数字，并且按出现顺序排列 双标记既可作为区块标记又可作为行内标记的标记。 代码块 1) 行内代码块 语法：使用两个 ` 将代码包含起来 示例代码 在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;); 在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;); 2) 多行代码块 语法：只需要每行都缩进 4 个空格即可，或者使用123456789101112131415 示例代码 1 (行前4个空格) // JQuery 的 Hello, world $(function()&#123; alert(&quot;Hello, world!&quot;) &#125;);效果(行前4个空格)// JQuery 的 Hello, world$(function()&#123; alert(&quot;Hello, world!&quot;)&#125;);示例代码 2 (```) // JQuery 的 Hello, world$(function(){alert(“Hello, world!”)});` 效果 (`) // JQuery 的 Hello, world$(function(){ alert(“Hello, world!”)}); 注意事项： 在代码区块内部，&quot;, &lt;&gt;,&amp; 将会自动转换为转义字符 在代码区块内部，Markdown 标记将保持原样，即：星号(*)就是星号(*)，不被解释为特殊标记，这样就可以不能继续使用 Markdown 语法了 表格语法： 第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符 | 隔开。表格每一行两边的管道符可省略。 第二行还可以为不同的列指定对齐方向。标题默认为居中对齐，内容默认为左对齐；在 - 左边加上 : 就是左对齐；在 - 右边加上 : 就是右对齐；在 - 两边都加上 : 就是居中对齐。 示例代码 姓名|语文成绩|数学成绩|总成绩 ---|:---|:---:|---: 喜羊羊|100|120|220 姓名 语文成绩 数学成绩 总成绩 喜羊羊 100 120 220 其他问题 Markdown 与 HTML 的关系 HTML 是一种发布的格式，Markdown 是一种书写的格式。 Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 在 Markdown 中可直接使用 HTML 标签，但需要注意 对于 HTML 区块元素――如 div、table、pre、p 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符(tab)或空格来缩进 HTML 的行内标签——如 span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用。 在 HTML 的区块标签中的 Markdown 标签是没有效果的 特殊字符的自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp;，必须使用转义字符：&amp; lt ; 和 &amp; amp ; Markdown 中，你可以自由的书写 &lt; 和 &amp;，编辑器会智能的进行判断：当这些符号用于 HTML 标签中，他们将保留原型；当他们单独使用时，将会转换为字符实体。 在代码块中，它们将统统被转换为字符实体，即：原样显示。 Markdown 中的转义字符 Markdown 中，如需显示有特定意义的符号，如：*,# 等，可使用 反斜杠 \ 进行转义。可对如下字符进行转义： * ` *_ {} () # + - . ! 作者：白老师课堂链接：https://www.jianshu.com/p/4e3cae082b47來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <tags>
        <tag>markdown 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
