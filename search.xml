<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nuxt.js学习]]></title>
    <url>%2F2018%2F05%2F16%2Fframe%2Fnuxt%2F</url>
    <content type="text"><![CDATA[关于Nuxt.js2016年10月25日，zeit.co背后的团队对外发布了Next.js，一个react的服务端渲染应用框架。几个小时后，与Next.js异曲同工，一个基于vue.js的服务端渲染应用框架应用而生，我们称之：Nuxt.js。 Nuxt.js是什么？Nuxt.js是一个基于vue.js的通用应用框架 通过对客户端/服务端基础架构的抽象组织，Nuxt.js只要关注的是应用的UI渲染 我们的目标是插件一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有的Node.js项目中使用Nuxt.js Nuxt.js预设了利用vue.js开发服务端渲染的应用所需要的各种配置 除此之外，我们还提供了一种命令叫：nuxt generate，为基于vue.js的用用提供生成对应的静态站点的功能 我们相信这个命令所提供的功能，是向开发集成各种微服务的web应用迈开的新一步 作为框架，nuxt.js为客户端/服务端这种典型的应用框架模式提供了许多有用的特性，例如异步数据加载，中间件支持，布局支持等]]></content>
      <tags>
        <tag>前端框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环]]></title>
    <url>%2F2018%2F05%2F15%2Fjavascript%2Fjs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[一、为什么JS是单线程是由JS的用途决定的，其用途主要是与用户互动，以及操作DOM，如果不是单线程的话会带来很复杂的同步问题。比如：如果是多线程的话，一个用户新建一个DOM，另一个用户删除同一个DOM，该如何处理将变得非常麻烦。 在html5中提出了web worker（todo 改天添加web worker的讲解）标准，JS可以创建多个线程或者是iframe，但是其他子线程主要是用来进行JS计算不能操作DOM，且受到子线程的控制。所以也并没有改变JS单线程的本质 二、同步和异步由于是单线程，所有任务需要排队，但是如果队列中所有的任务都是同步的话会造成资源的浪费。 于是任务分为两类：同步任务和异步任务。 异步任务的过程： 主线程（函数调用栈）发起一个异步请求，相应的工作线程接收请求，并告知主线程已经收到，主线程继续执行后面的同步代码，同时工作线程执行异步任务，工作线程完成工作后，通知主线程，主线程收到通知后，执行回调函数 三、宏任务和微任务宏任务（micro-task）主要是：script代码段、setTimeout、setInterval、Promise的构造函数是同步的、setImmediate、I/O、UIrendering 微任务（macro-task）主要是：Promise的回调、process.nextTick 四、任务队列和事件循环了解任务队列之前，先了解一下任务源，我们将发起异步任务的称之为任务源（setTimeout、Promise等），进入任务队列的是他们指定的任务。 在一个线程中，事件循环是唯一的，任务队列是多个的。来自不同任务源的队列进入到不同的任务队列，setTimeout和setInterval是同源的 事件循环的步骤：1、运行主线程（函数调用栈）中的同步任务 2、主线程（函数调用栈）执行到任务源时，通知相应的webAPIs进行相应的执行异步任务，将任务源指定的异步任务放入任务队列中 3、主线程（函数调用栈）中的任务执行完毕后，然后执行所有的微任务，再执行宏任务，找到一个任务队列执行完毕，再执行所有的微任务 4、不断执行第三步 事件循环：指主线程重复从任务队列中取消息，执行的过程 先来一个简单的例子： setTimeout(() =&gt; { console.log(&apos;begin&apos;) }) new Promise((resolve) =&gt; { console.log(&apos;promise begin&apos;) for(let i = 0; i &lt; 1000; i++) { i == 999 &amp;&amp; resolve() } }).then(() =&gt; { console.log(&apos;then begin&apos;) }) console.log(&apos;end&apos;) 因为promise的构造函数是同步的，promise.then是异步的微任务，所以promise beigin先于end根据上面对宏任务和微任务的分析，其输出的情况为【promise begin——end——then begin——begin】再来一个复杂点的，我们来一步一步的分析一个例子来看： console.log(&apos;golb1&apos;); setTimeout(function() { console.log(&apos;timeout1&apos;); process.nextTick(function() { console.log(&apos;timeout1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;timeout1_promise&apos;); resolve(); }).then(function() { console.log(&apos;timeout1_then&apos;) }) }) setImmediate(function() { console.log(&apos;immediate1&apos;); process.nextTick(function() { console.log(&apos;immediate1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;immediate1_promise&apos;); resolve(); }).then(function() { console.log(&apos;immediate1_then&apos;) }) }) process.nextTick(function() { console.log(&apos;glob1_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;glob1_promise&apos;); resolve(); }).then(function() { console.log(&apos;glob1_then&apos;) }) setTimeout(function() { console.log(&apos;timeout2&apos;); process.nextTick(function() { console.log(&apos;timeout2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;timeout2_promise&apos;); resolve(); }).then(function() { console.log(&apos;timeout2_then&apos;) }) }) process.nextTick(function() { console.log(&apos;glob2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;glob2_promise&apos;); resolve(); }).then(function() { console.log(&apos;glob2_then&apos;) }) setImmediate(function() { console.log(&apos;immediate2&apos;); process.nextTick(function() { console.log(&apos;immediate2_nextTick&apos;); }) new Promise(function(resolve) { console.log(&apos;immediate2_promise&apos;); resolve(); }).then(function() { console.log(&apos;immediate2_then&apos;) }) }) 一、第一步、首先执行宏任务script。全局入栈。输出glob1 二、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列 三、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列 四、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列 五、遇到Promise的构造函数，进入执行栈，输出glob1_promise，Promise.then()作为任务源，将指定的任务加入微任务 六、遇到setTimeout，作为任务源，将指定的任务加入宏任务队列 七、遇到process.nextTick，作为任务源，将指定的任务加入微任务队列 八、遇到Promise的构造函数，进入执行栈，输出glob2_promise，Promise.then()作为任务源，将指定的任务加入微任务 九、遇到setImmediate，作为任务源，将指定的任务加入宏任务队列 十、执行所有微任务队列，输出glob1_nextTick和glob2_nextTick、glob1_then、glob2_then 事件机制其实就是异步任务的通知机制]]></content>
      <tags>
        <tag>前端js学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[段落第一自然段 第二自然段 注意：换行不是分段的标识，空行才是 标题一级标题二级标题三级标题四级标题五级标题六级标题注：# 和后续内容之间应放置一个空格 列表(1) 有序列表 打开冰箱门 把大象放进冰箱 关上冰箱门 (2) 无序列表 吃饭 睡觉 打豆豆 注意事项： 无序列表的项目符号可使用 *,+,- 效果是相同的。 列表与后续内容之间需要一个空行隔开，即：列表是一个段落 列表允许多层次嵌套 可以在项目中包含段落，只需将段落前添加一个 tab 或 4 个空格 分割线语法：使用 3 个连续的 * 即可得到一个分割线 引用语法：在行头加上 &gt; 即可。 这里是一段引用 大于号 和 文字必须有一个空格 可以在每行之前加 &gt; ，也可以在段落之前加 1 个 &gt; 引用内部可以使用其他 Markdown 标记 引用内部可以添加新的引用，只需再加一个大于号 行内标记(1) 强调文字 斜体 语法：使用前后各 1 个 *(或_) 包含的文字是 斜体 文字 *斜体*, _斜体_ 粗体 语法：使用前后各 2 个 *(或_) 包含的文字是 粗体 文字 **粗体**，__粗体__ 删除文字 语法：使用前后各 2 个 ~ 包含的文字是删除文字 ~~删除~~ 粗斜体 语法：在**(或__)中嵌套_ (或*) 或 在_(或*)中嵌套**(或__)即可得到 粗斜体。 _**粗斜体**_， *__粗斜体__* **_粗斜体_**， __*粗斜体*__ (2) 图片与链接 1.图片：行内图片、引用图片 1&gt; 行内图片 图片和图片地址写在一起。 语法： ![图片标题](图片url) ![史努比](http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 2&gt; 引用图片 图片和图片地址分开书写。 语法： ![图片标题][图片id] [图片id]:图片url ![史努比][snoopy] [snoopy]: http://upload-images.jianshu.io/upload_images/2779565-13b3439b110c16bf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 2. 链接：行内链接、链接引用、自动链接 1&gt; 行内链接 语法：[链接名称](链接地址 url &quot;链接title&quot;) 示例代码 [新浪](http://www.sina.com.cn &quot;新浪主页&quot;) 新浪 注意事项 双引号中的内容是链接的 title (目前汉字显示不正确) 2&gt; 链接引用 一种链接和地址分离的方式。 [链接名称][链接id] [链接id]:链接 url 地址 &quot;链接 title&quot; 示例代码 根据 [雅虎][yahoo] 的调查，希拉里将当选；根据 [谷歌][google] 的调查，川普将当选。 [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [google]: http://google.com/ &quot;Google&quot; 根据 雅虎 的调查，希拉里将当选；根据 谷歌 的调查，川普将当选。 注意事项 链接 id 可使用字母、数字、空格，但不区分大小写 3.脚注 -- 为名词提供注释，注释将显示在文章末尾。 语法： 待解释文字[^脚注 id] [^脚注 id]:注释内容 示例代码 Hello程序[^hello] [^hello]:即：Hello, world 程序 Hello程序[^hello][^hello]:即：Hello, world 程序 注意事项 脚注 id 必须唯一 无论脚注 id 如何起名，显示时一律标为数字，并且按出现顺序排列 双标记既可作为区块标记又可作为行内标记的标记。 代码块 1) 行内代码块 语法：使用两个 ` 将代码包含起来 示例代码 在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;); 在 Java 输出 Hello, world ：System.out.print(&quot;Hello, World!&quot;); 2) 多行代码块 语法：只需要每行都缩进 4 个空格即可，或者使用123456789101112131415 示例代码 1 (行前4个空格) // JQuery 的 Hello, world $(function()&#123; alert(&quot;Hello, world!&quot;) &#125;);效果(行前4个空格)// JQuery 的 Hello, world$(function()&#123; alert(&quot;Hello, world!&quot;)&#125;);示例代码 2 (```) // JQuery 的 Hello, world$(function(){alert(“Hello, world!”)});` 效果 (`) // JQuery 的 Hello, world$(function(){ alert(“Hello, world!”)}); 注意事项： 在代码区块内部，&quot;, &lt;&gt;,&amp; 将会自动转换为转义字符 在代码区块内部，Markdown 标记将保持原样，即：星号(*)就是星号(*)，不被解释为特殊标记，这样就可以不能继续使用 Markdown 语法了 表格语法： 第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符 | 隔开。表格每一行两边的管道符可省略。 第二行还可以为不同的列指定对齐方向。标题默认为居中对齐，内容默认为左对齐；在 - 左边加上 : 就是左对齐；在 - 右边加上 : 就是右对齐；在 - 两边都加上 : 就是居中对齐。 示例代码 姓名|语文成绩|数学成绩|总成绩 ---|:---|:---:|---: 喜羊羊|100|120|220 姓名 语文成绩 数学成绩 总成绩 喜羊羊 100 120 220 其他问题 Markdown 与 HTML 的关系 HTML 是一种发布的格式，Markdown 是一种书写的格式。 Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 在 Markdown 中可直接使用 HTML 标签，但需要注意 对于 HTML 区块元素――如 div、table、pre、p 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符(tab)或空格来缩进 HTML 的行内标签——如 span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用。 在 HTML 的区块标签中的 Markdown 标签是没有效果的 特殊字符的自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp;，必须使用转义字符：&amp; lt ; 和 &amp; amp ; Markdown 中，你可以自由的书写 &lt; 和 &amp;，编辑器会智能的进行判断：当这些符号用于 HTML 标签中，他们将保留原型；当他们单独使用时，将会转换为字符实体。 在代码块中，它们将统统被转换为字符实体，即：原样显示。 Markdown 中的转义字符 Markdown 中，如需显示有特定意义的符号，如：*,# 等，可使用 反斜杠 \ 进行转义。可对如下字符进行转义： * ` *_ {} () # + - . ! 作者：白老师课堂链接：https://www.jianshu.com/p/4e3cae082b47來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <tags>
        <tag>markdown 语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
